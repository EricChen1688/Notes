## TCC补偿型方案

## 目录

------

[TOC]

## 什么是TCC补偿方案

TCC (Try、Commit、Cancel) 是一种补偿型事务，该模型要求应用的每个服务提供 try、confirm、cancel 三个接口，它的核心思想是通过对资源的预留（提供中间态），尽早释放对资源的加锁，如果事务可以提交，则完成对预留资源的确认，如果事务要回滚，则释放预留的资源。

TCC 也是一种两阶段提交协议，可以看作 2PC/XA 的一种变种，但是不会长时间持有资源锁。

- Try：这个阶段主要是对数据的校验或者资源的预留。
- Confirm：确认真正执行的任务，只操作Try阶段预留的资源。
- Cancel：取消执行，释放Try阶段预留的资源。

**其实TCC是一种两阶段提交的思想**

 [030-两阶段提交协议.md](030-两阶段提交协议.md) 

- 第一阶段通过Try进行准备工作
- 第二阶段Confirm/Cancel 表示Try阶段操作的确认和回滚。

在分布式事务场景中，每个服务实现TCC之后，就作为其中的一个资源，参与到整个分布式事务中。然后主业务服务在第一阶段中分别调用所有TCC服务的Try方法。最后根据第一个阶段的执行情况来决定对第二阶段的Confirm或者Cancel。

## TCC执行流程图

<img src="../../assets/image-20200903120559862.png" alt="image-20200903120559862" style="zoom:50%;" />

## TCC例子

我们以一个简单的电商系统为例，小明在淘宝上花 100 元买了一本书，获赠 10 个积分，产品上有如下几个操作：

- 订单系统创建商品订单
- 支付系统接受小明的支付
- 库存系统扣减产品库存
- 会员系统给小明账户增加会员积分

这几个动作需要作为一个事务执行，要同时成功或者同时撤销。

如果采用 TCC 事务模式，那么各个系统需要改造为如下状态：

1）订单系统

- try：创建一个订单，状态显示为“待支付”
- confirm：更新订单的状态为“已完成”
- cancel：更新订单的状态为“已取消”

2）支付系统

- try：假设小明账户中有 1000 元，冻结小明账户中的 100 元，此时小明看到的余额依然是 1000 元。
- confirm：将账户余额变为 900 元，并清除冻结记录。
- concel：清除冻结记录。

3）库存系统

- try：假设库存中还生 10 本书，冻结其中的一本书，现实库存依然有 10 本书。
- confirm：将剩余库存更新为 9 本书，并清除冻结记录。
- cancel：清除冻结记录。

4）会员系统

- try：假设小明原因积分 3000 分，给小明账户预增加 10 积分，账户显示的积分依然是 3000 分。
- confirm：将账户积分更新为 3010，并清除预增加记录。
- cancel：清除预增加记录。

## 服务突然宕机无法收到事务协调器

**在一些特殊情况下，比如理财产品服务宕机或者出现异常，导致该服务并没有收到TCC事务协调器的Cancel或者Confirm请求，怎么办呢？**

没关系，TCC事务框架会记录一些分布式事务的操作日志，保存分布式事务运行的各个阶段和状态。TCC事务协调器会根据操作日志来进行重试，以达到数据的最终一致性。

**需要注意的是，TCC服务支持接口调用失败发起重试，所以TCC暴露的接口都需要满足幂等性。**

## TCC的特点

TCC 事务具备事务的四个特性：

- **原子性**：事务发起方协调各个分支事务全部提交或者全部回滚。
- **一致性**：TCC 事务提供最终一致性。
- **隔离型**：通过 try**预分配资源**的方式来实现数据的隔离。(中间状态)
- **持久性**：交由各个分支事务来实现。

## 缺点

**TCC 事务模型对业务方侵入较大，需要业务方把功能的实现上由一个接口拆分为三个，开发成本较高**。

同时 TCC 事务为了解决异步网络中的通信失败或超时带来的异常情况，要求业务方在设计实现上要遵循三个策略：

- 允许空回滚：原因是异常发生在阶段 1 时，部分参与方没有收到 try 请求从而触发整个事务的 cancel 操作，try 失败或者没有执行 try 操作的参与方收到 cancel 请求时，要进行空回滚操作。
- 保持幂等性：原因是异常发生在阶段 2 时，比如网络超时，则会重复调用参与方的 confirm/cancel 方法，因此需要这两个方法实现上保证幂等性。
- 防止资源悬挂：原因网络异常导致两个阶段无法保证严格的顺序执行，出现参与方侧 try 请求比 cancel 请求更晚到达的情况，cancel 会执行空回滚而确保事务的正确性，但是此时 try 方法也不可以再被执行。

TCC 事务将分布式事务从资源层提到业务层来实现，可以让业务灵活选择资源的锁定粒度，并且全局事务执行过程中不会一直持有锁，所以系统的吞吐量比 2PC/XA 模式要高很多。

支持 TCC 事务的开源框架有：ByteTCC、Himly、TCC-transaction。