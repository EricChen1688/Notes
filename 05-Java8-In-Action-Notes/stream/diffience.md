[返回目录](/README.md)

# 流与集合

我们用一个比喻来解释内部迭代的差异和好处

比方说你在和你两岁的女儿索菲亚说  
话，希望她能把玩具收起来。

你：“索菲亚，我们把玩具收起来吧。地上还有玩具吗？”

索菲亚：“有，球。”

你：“好，把球放进盒子里。还有吗？”

索菲亚：“有，那是我的娃娃。”

你：“好，把娃娃放进盒子里。还有吗？”

索菲亚：“有，有我的书。”

你：“好，把书放进盒子里。还有吗？”

索菲亚：“没了，没有了。”

你：“好，我们收好啦。”

这正是你每天都要对Java集合做的。你外部迭代一个集合，显式地取出每个项目再加以处理。

如果你只需跟索菲亚说“把地上所有的玩具都放进盒子里”就好了。内部迭代比较好的原因有二：

  
第一，索非亚可以选择一只手拿娃娃，另一只手拿球；

第二，她可以决定先拿离盒子最近的那个东西，然后再拿别的。

同样的道理，内部迭代时，项目可以透明地并行处理，或者用更优化的顺序进行处理。要是用Java过去的那种外部迭代方法，这些优化都是很困难的。这似乎有点儿鸡蛋里挑骨头，但这差不多就是Java 8引入流的理由了——Streams库的内部迭代可以自动选择一种适  
合你硬件的数据表示和并行实现。与此相反，一旦通过写 for-each 而选择了外部迭代，那你基本上就要自己管理所有的并行问题了（自己管理实际上意味着“某个良辰吉日我们会把它并行化”或“开始了关于任务和 synchronized 的漫长而艰苦的斗争”）。Java 8需要一个类似于Collection 却没有迭代器的接口，于是就有了 Stream ！图4-4说明了流（内部迭代）与集合（外部迭代）之间的差异。

![](/assets/import12.png)

[返回目录](/README.md)

