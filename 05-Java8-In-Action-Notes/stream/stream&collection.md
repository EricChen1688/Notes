[返回目录](/README.md)

# 流与集合

Java现有的集合概念和新的流概念都提供了接口，来配合代表元素型**有序值**的数据接口。所谓有序，就是说我们一般是按照顺序取用值而不是随机取用的。

集合与流之间的差异在于什么时候进行计算。

集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。你可以往集合中加东西或者删除东西，但是不管什么时候，集合中的每个元素都是放在内存中的，元素都得先算出来才能成为集合的一部分。

流是概念上**固定的数据结构（**你不能添加或者删除元素**），**其元素则是按需计算的，这对编程有很大的好处。在第6章中，我们将展示构建一个质数流（2, 3, 5, 7, 11, …）有

多简单，尽管质数有无穷多个。这个思想就是用户仅仅从流中提取需要的值，而这些值——在用  
户看不见的地方——只会按需生成。这是一种生产者－消费者的关系。从另一个角度来说，流就  
像是一个延迟创建的集合：只有在消费者要求的时候才会计算值（用管理学的话说这就是需求驱  
动，甚至是实时制造\)。

与此相反，集合则是急切创建的（供应商驱动：先把仓库装满，再开始卖，就像那些昙花一  
现的圣诞新玩意儿一样）。以质数为例，要是想创建一个包含所有质数的集合，那这个程序算起  
来就没完没了了，因为总有新的质数要算，然后把它加到集合里面。当然这个集合是永远也创建  
不完的，消费者这辈子都见不着了。

## ![](/assets/import11.png)流只能遍历一次

请注意，和迭代器类似，**流只能遍历一次**。遍历完之后，我们就说这个流已经被消费掉了。  
你可以从原始数据源那里再获得一个新的流来重新遍历一遍，就像迭代器一样（这里假设它是集  
合之类的可重复的源，如果是I/O通道就没戏了）。例如，以下代码会抛出一个异常，说流已被消  
费掉了

```
List<String> title = Arrays.asList("Java8", "In", "Action");
Stream<String> s = title.stream();
s.forEach(System.out::println);
s.forEach(System.out::println);
```

## 外部迭代与内部迭代

使用 Collection 接口需要用户去做迭代（比如用 for-each ），这称为**外部迭代**。

相反，

Streams库使用**内部迭代**——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。

[返回目录](/README.md)

