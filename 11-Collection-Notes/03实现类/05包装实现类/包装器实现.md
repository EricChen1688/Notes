# Wrapper Implementations

# 包装器实现类

包装器实现类包装了特定集合使其具有附加功能，对于设计模式而言，使用的是装饰者模式，虽然比较奇异，但是简洁。

`Collections`类中包含的静态工厂方法提供了这些特性：

## 同步包装器

将线程非安全的类转化成自动同步（线程安全的）集合，支持6种核心接口- [`Collection`](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html), [`Set`](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html), [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html), [`Map`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html), [`SortedSet`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html), and [`SortedMap`](https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html) 

```
public static <T> Collection<T> synchronizedCollection(Collection<T> c);
public static <T> Set<T> synchronizedSet(Set<T> s);
public static <T> List<T> synchronizedList(List<T> list);
public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m);
public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s);
public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m);
```

上面的方法是在原有`Collection`的基础上进行包装，依然引用了原集合，操作这些集合实际上也对原集合进行了修改，比较方便地去除掉对原集合的引用，使用下面的简单例子：

```
List<Type> list = Collections.synchronizedList(new ArrayList<Type>());
```

在多线程访问时，用户自己在迭代期间手动同步是有必要的，因为可能是通过多个调用来完成的，这些调用必须祖冲一个原子操作，下面是在包装同步集合上迭代的习惯用法

```
Collection<Type> c = Collections.synchronizedCollection(myCollection);
synchronized(c) {
    for (Type e : c)
        foo(e);
}

```

上面的例子中的`c`实际上底层还是对`myCollection`的引用，在非局部变量操作这个集合时，要进行加锁。因为`myCollection`有可能在别的线程中被修改。

获取迭代器没有进行同步：

![1550814171573](assets/1550814171573.png)

如果使用显式迭代器，则必须从同步块内调用迭代器方法。不遵守此建议可能导致不确定性行为。在同步映射的集合视图上迭代的习惯用法类似。当用户迭代其任何集合视图时，必须在同步映射上同步，而不是在集合视图本身上同步，如下例所示。

```
Map<KeyType, ValType> m = Collections.synchronizedMap(new HashMap<KeyType, ValType>());
    ...
Set<KeyType> s = m.keySet();
    ...
// Synchronizing on m, not s!
synchronized(m) {
    while (KeyType k : s)
        foo(k);
}
```

使用包装实现的一个小缺点是，您没有能力执行包装实现的任何非交互操作。因此，例如，在前面的列表示例中，您不能在包装好的`ArrayList`上调用`ArrayList`的`EnsureCapacity`操作。

## 不可变包装器

通过抛出`UnsupportedOperationException`来确保不能被改变，

应用场合：

- 构建一次后不能修改的集合
- 构造只读集合

```
public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c);
public static <T> Set<T> unmodifiableSet(Set<? extends T> s);
public static <T> List<T> unmodifiableList(List<? extends T> list);
public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m);
public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<? extends T> s);
public static <K,V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m);
```

## Checked Interface Wrappers

```

```

`Collections.checked`如果客户端尝试添加错误类型的元素，这些实现返回指定集合的`动态类型`安全视图，会抛出`ClassCastException`,语言中的泛型机制提供了编译时（静态）类型检查，但有可能会破坏这种机制。动态类型安全视图完全消除了这种可能性。