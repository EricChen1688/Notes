# 兼容性

如何在你的程序中兼容`Collection`框架中的老实现

 [`Vector`](https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html), [`Hashtable`](https://docs.oracle.com/javase/8/docs/api/java/util/Hashtable.html), [array](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html), and[`Enumeration`](https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html)

以及，如何将新的实现应用到老的方法上，

## 向上兼容

老集合类->新集合类array 

使用`Arrays.asList`将任何类型的`Collection`

```
Foo[] result = oldMethod(arg);
newMethod(Arrays.asList(result));

```

如果老的API返回一个`Vector`者是一个`Hashtable`,无序转换，因为`Vector`实现了`List`,`HashTable`实现了`Map`：

```
Vector result = oldMethod(arg);
newMethod(result);
```

Similarly, a `Hashtable` may be passed directly to any method calling for a `Map`.

```
Hashtable result = oldMethod(arg);
newMethod(result);
```

在少数情况下：返回一个`Enumeration` 时，`Collections.list`可以把一个`Enumeration` 转化为一个`Collection`

```
Enumeration e = oldMethod(arg);
newMethod(Collections.list(e));
```

## 向下兼容

将新实现转化为旧实现：

假如新API返回一个`Collection`，旧API需要一个Object 的Array:

`Collection` interface 包含一个 `toArray` 方法

```
Collection c = newMethod();
oldMethod(c.toArray());
```

强转：

```
Collection c = newMethod();
oldMethod((String[]) c.toArray(new String[0]));
```

如果 API 需要一个 `Vector`, 可以使用构造器：

```
Collection c = newMethod();
oldMethod(new Vector(c));
```

```
Map m = newMethod();
oldMethod(new Hashtable(m));
```

Finally, what do you do if the old API requires an `Enumeration`? This case isn't common, but it does happen from time to time, and the[`Collections.enumeration`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-) 方法可以将`Collection 转化为`Enumeration`

```
Collection c = newMethod();
oldMethod(Collections.enumeration(c));
```