# Object Ordering

我们声明一个`list l`:

排序：

```
Collections.sort(l);
```



如果`List`包含`String`元素，它会根据字母表的顺序排序，如果她包含一个`Date`元素，它会根据时间先后排序，为什么会这样呢，因为`String`和`Date`都实现了`Comparable`接口，`Comparable`接口提供了一个类的排序方式，允许类根据指定方式排序。下面的表格汇总了Java平台上实现`Comparable`的类：

| Class | Natural Ordering |
| ----- | ---------------- |
|  Byte     |  Signed numerical                |
|    Character   |      Unsigned numerical            |
| Long | Signed numerical |
| Integer | Signed numerical |
| Short | Signed numerical |
| Double | Signed numerical |
| Float | Signed numerical |
| BigInteger | Signed numerical |
| BigDecimal | Signed numerical |
| Boolean | Boolean.FALSE < Boolean.TRUE |
| File | System-dependent lexicographic on path name |
| String | Lexicographic |
| Date | Chronological |
| CollationKey | Locale-specific lexicographic |

## 自己实现Comparable 类型

实现`Comparable`接口，重写compareTo方法.返回值：

```
public interface Comparable<T> {
    public int compareTo(T o);
}
```



| 返回值 | 代表含义 |
| ------ | -------- |
| 正数   | 大于     |
| 0      | 相同     |
| 负数   | 小于     |



```
import java.util.*;

public class Name implements Comparable<Name> {
    private final String firstName, lastName;

    public Name(String firstName, String lastName) {
        if (firstName == null || lastName == null)
            throw new NullPointerException();
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String firstName() { return firstName; }
    public String lastName()  { return lastName;  }

    public boolean equals(Object o) {
        if (!(o instanceof Name))
            return false;
        Name n = (Name) o;
        return n.firstName.equals(firstName) && n.lastName.equals(lastName);
    }

    public int hashCode() {
        return 31*firstName.hashCode() + lastName.hashCode();
    }

    public String toString() {
	return firstName + " " + lastName;
    }

    public int compareTo(Name n) {
        int lastCmp = lastName.compareTo(n.lastName);
        return (lastCmp != 0 ? lastCmp : firstName.compareTo(n.firstName));
    }
}
```


	

上面代码：

- 构造器检查了形参的值是否为`null`，确保所有的`Name`对象的形式一致且完好，其他方法不会抛出`NullPointerException`.
- `hashCode`方法被重新定义了，当重写`equals`时，重写`hashCode`方法是基础，因为相同的对象必须要有相同的`hashCode`.
- `equals`方法返回一个`false`，如果指定的对象时`null`或者是一个不合适的类型，`compareTo`方法会抛出一个运行时异常。
- `toString`方法重写以更加适合阅读的方式打印`name`，这往往是一个好主意，尤其是很多对象要加入一个集合时。



`compareTo`方法很特别，因为它实现了标准的姓名排序方法，姓氏优先于名字。

```
import java.util.*;

public class NameSort {
    public static void main(String[] args) {
        Name nameArray[] = {
            new Name("John", "Smith"),
            new Name("Karl", "Ng"),
            new Name("Jeff", "Smith"),
            new Name("Tom", "Rich")
        };

        List<Name> names = Arrays.asList(nameArray);
        Collections.sort(names);
        System.out.println(names);
    }

```

输出：

```
[Karl Ng, Tom Rich, Jeff Smith, John Smith]
```

## Comparators

如果你不想以实现`comparable`的方式实现比较，你需要提供一个`Comparator`

```
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

使用`Comparator`进行比较：

```
import java.util.*;
public class EmpSort {
    static final Comparator<Employee> SENIORITY_ORDER = 
                                        new Comparator<Employee>() {
            public int compare(Employee e1, Employee e2) {
                return e2.hireDate().compareTo(e1.hireDate());
            }
    };

    // Employee database
    static final Collection<Employee> employees = ... ;

    public static void main(String[] args) {
        List<Employee> e = new ArrayList<Employee>(employees);
        Collections.sort(e, SENIORITY_ORDER);
        System.out.println(e);
    }
}
```



