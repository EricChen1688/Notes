# 02-可达性分析算法

[TOC]

## 什么是可达性分析

以一个 CG roots 作为起点向下搜索,当一个对象到任何 GC Roots 都没有引用连接时,如果 GC roots 和一个对象之间没有可达路径,则称对象时不可达的,不可达对象至少要经过两次标记才能判定其是否可以被回收,如果在两次标记后对该对象任然是不可达的,将会被垃圾回收器回收

Java 采用引用计数法和可达性分析来确定对象是否应该被回收,其中,

- 引用计数法容易产生循环引用的问题

- 可达性分析算法通过根搜索算法(GC roots Tracing)来实现,根搜索算法以一些列 GCROOTS 的点作为起点向下搜索,在一个对象到任意 GC roots都没有引用链项链的时候,说明已经死亡

  ![image-20200526211023099](../../assets/image-20200526211023099-3836292.png)

在主流的商用程序语言的主流实现中,都是称通过可达性分析来判断对象是否存活

## 可达性分析图示

<img src="../../assets/image-20200503141338936.png" alt="image-20200503141338936" style="zoom: 50%;" />

通过一系列成为 GC roots 的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链

当一个对象到 GC roots 没有任何引用链的时候,证明此对象不可用

- objt5
- object6
- object7

虽然有关联,但是他们到 GCroot 没有任何引用链,就将会被判定为可回收的

## Java语言中可作为GCroots的对象

具体来说

- **虚拟机栈(栈帧中的本地变量表) 中引用的对象** ,例如参数,局部变量,临时变量
- **方法区中类静态属性引用的变量,** 譬如 Java类中的引用类型静态变量
- **方法区中常量引用的对象** , 譬如字符串常量池中引入的变量
- 本地方法栈中 JNI(也就是我们常说的 navtive 方法)引用的对象 
- **虚拟机内部的引用, 如基本数据类型对应的 class 对象, 一些常驻的异常对象(比如 NullPointException . OutOfMemoryError)**
- **所有被同步锁持有的对象 Synchronzied 持有对象**
- **反映虚拟机运行情况的 JMX Bean, JVMTI中注册的回调,本地代码缓存等等**

