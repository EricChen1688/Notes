# 线程的实现

> 以 hotSpot 为例子, 每一个 Java 线程都是直接映射到操作系统原生线程来实现的, 中间没有任何额外的间接结构,所以以 HotSpot 自己是不会干涉线程调度的(可以设置线程优先级给操作系统提供调度建议)
>
> 全权交给操作系统去处理,所以合适解冻或者唤醒线程,该给线程分配多少处理器执行时间,该把线程安排给哪个处理器核心去执行等等,都是操作系统去完成的,也都是操作系统全权决定的



- 线程是比进程更轻量级的执行单位

> 线程的引入可以把一个进程资源和执行调度分开
>
> 各个线程既可以共享进程资源(内存地址, 文件 IO 等等), 又可以独立调度

- 线程是 Java里进行处理器资源调度的最基本的单位

> 如果日后 Loom 项目能够成功为 Java 引入纤程(Fiber) 的话,可能就会改变这一点

- 为什么Java Thread 中的 start 方法是个 native 方法?

> 实际上native 方法往往意味着这个方法没有办法 **使用平台无关**的手段来实现

实现线程的方式有三种

- 内核线程实现 1:1 
- 使用用户线程实现 1:N 实现
- 使用用户线程加轻量级进程混合实现 (N :  M)

## 内核进程实现  一对一

这里的1: 1 意思是指的是 

**轻量级进程和内核线程之间的 1:1 的关系**

> 轻量级进程实际上就是我们所说的线程

#### 什么是内核线程(Kernel-Level Thread KLT)

> 内核线程(Kernel-Level Thread KLT) 是直接由操作系统内核(Kernel, 内核) 支持的线程,这种线程由内核来完成线程切换,内核通过操纵调度器(Scheduler) 对线程进行调度,并负责将线程的任务映射到各个处理器上

每个内核线程可以视为内核的一个分身,这样操作系统就有能力同时处理多件事情,支持多线程的内核就成为多线程内核

程序一般不会直接使用内核线程,而是使用内核线程的一种高级接口 -- 轻量级进程(Light Weight Process , LWP)

> 轻量级进程就是我们通常意义上讲的线程 , 由于每个轻量级进程都由一个内核线程支持, 因此只有先支持内核线程,才能有轻量级进程

<img src="../../assets/image-20200620171407363.png" alt="image-20200620171407363" style="zoom:50%;" />

#### 系统支持轻量级进程是有限的

由于内核线程的支持,每个轻量级进程都成为了一个独立的调度单元,即使其中某一个轻量级进程在系统调用中被阻塞了,也不会影响整个进程继续工作

轻量级进程的局限性:

- 由于急于内核线程来实现,所以各种线程操作 . 创建, 析构以及同步, 都需要进行系统调用, 而系统调用的代价相对较高,需要从 用户态(User Mode) 和内核态(Kernel Mode)之间来回切换
- 每个轻量级进程都需要有一个内核线程支持,因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间),因此一个系统支持轻量级进程的数量是有限的

