# 上下文类加载器

## 什么是上下文类加载器

> 上下文类加载器可以通过 `java.lang.Thread#setContextClassLoader()` 方法为线程设置一个类加载器
>
> - 如果创建线程的时候没有设置,默认会从父线程集成一个
>
> - 如果在应用程序的全局范围内没有设置,那么类加载器默认就是应用程序类加载器(Application ClassLoader)

## 为什么要有上下文类加载器? 它解决什么问题

我们知道,双亲委派模型可以解决 **各个类加载器协作时基础类型的一致性问题**, 越是基础的类由越上层的加载器加载

> 基础的类之所以被成为"基础",是因为他们总是作为被用户代码继承,调用 API 存在

但是如果基础的类需要进行调用用户的代码的时候怎么办呢

- JNDI  ,  由启动类加载器来完成加载

  > 主要是用来对资源进行查找和集中管理,它需要调用由其他厂商实现并部署在应用程序 CLassPath 下的 JNDI 服务提供者接口(Service Provider API , SPI)

- JDBC , 通过指定 LoaderService 的加载器为当前线程,从而将加载的方式通过厂商来实现

  >  [010-SPI在 JDBC中的应用.md](../../16-JSR/01-JDBC/010-SPI在 JDBC中的应用.md) 

- JCE

- JAXB

- JBI

等等

我们可以通过设置一个线程的类加载器,去加载这些所需要的 SPI 服务,

其实 SPI 是 父类加载器去请求子类夹杂器完成类加载的行为,这种行为实际上是逆向使用双亲委派	

## spi

JDK6 时, JDK 提供了一个` java.util.ServiceLoader` 类, `以META-INF/service` 中的配置信息,在加上责任链模式

 [spi笔记](../../04-java/01-basic/spi-service-provider-interface.md) 

## 指定注意的是

