# 类加载的时机

类的生命周期

<img src="../../assets/image-20200620224348640.png" alt="image-20200620224348640" style="zoom:50%;" />

JVM 类的加载分为 5 个阶段

- [加载](#加载)
  - [类的加载时机](#类的加载时机)
  - [加载做了什么](#加载做了什么)
- [连接](#连接)
  - [验证](#验证)
  - [准备](#准备)
  - [解析](#解析)
- [初始化](#初始化)
- 使用
- 卸载

## 加载

#### 类的加载时机

6 种情况必须要对类进行加载到初始化 ,**有且仅有**下面  6 种情况会执行类的初始化,

>  当然初始化之前的加载,验证,准备,解析自然要执行

1. **遇到 new , getstatic , putstatic ,  invokestatice 这四条字节码指令时候,如果类型没有进行过初始化,则触发加载,连接,初始化**

   > - new 指令: 使用new 关键字实例化对象的时候
   >
   > - getstatic 指令 : 读取一个类型的静态字段(被 final 修饰,已在编译器把结果放入常量池的静态字段除外) 的时候
   >
   > - putstatic 指令 : 设置一个类型的静态字段(被 final 修饰,已在编译器把结果放入常量池的静态字段除外) 的时候
   >
   > - invokestatic 指令 :调用一个类型的静态方法的时候

2. 使用 java.lang.reflect 包的方法对类型进行**反射调用**的时候,如果类型没有进行过初始化,则需要先触发其初始化

3. 当初始化类的时候 , 如果发现其父类还没有进行初始化,则先触发其父类的初始化

4. 当虚拟机启动的时候,用户需要制定一个要执行的主类(main 函数的类)虚拟机会初始化这个类 , 虚拟机会先初始化这个主类

5. 当使用 JDK7 新加入的动态语言支持时, 如果一个 java.lang,invoke.MethodHandle 实例最后的解析结果为以下四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化
   - REF_getStatic
   - REF_putStatic
   - REF_invokeStatic
   - REF_newInvokeSpecial
6. 当一个接口定义了 JDK8 加入的默认方法时 , 如果有这个接口的实现类发生了初始化,那这个接口也要**在其之前**被初始化

#### 加载做了什么

> 加载这个过程主要做了 : JVM 读取 Class 文件,并且根据 Class 文件描述创建` java.lang.Class` 对象的过程

类加载过程主要包含

1. **通过一个类的全限定名来获取定义这个类的二进制字节流**
2. **将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构**
3. **在内存中生成一个代表这个类的` java.lang.Class `对象,作为方法区这个类的各种数据的访问入口**

#### 类定义的字节流

可以是任意地方的,任意方式读取的字节流都可以加载,包括

- jar
- ear 
- war

- 可以从加密文件中获取,这是典型的防止 Class 文件反编译的保护措施,通过加载时解密 Class 文件来暴涨程序运行逻辑

- 等等各种方式,甚至可以网络中获取

> web applet

- 运行时计算获取,动态代理技术

> 比如 java.lang.reflect.Proxy 中,就用了 `ProxyGenerator.generateProxyClass()`来为特定接口生成形式为`*$Proxy`的代理类的二进制字节流

- 由其他文件生成,典型的就是 jsp,jsp 生成对应的 Class 文件
- 从数据库中读取, 比如一些中间件服务器(Sap Netweaver)可以选择吧程序安装到数据库中来完成集群间的分发

总结下:

- 将 Class文件读取到运行时区域的方法区内
- 在堆中创建 `java.lang.Class`对象,并封装类在方法区中的数据结构
- 读取 Class 文件时既可以通过文件形式读取,也可以通过 jar 包读取,war包读取,还可以通过代理自动生成 Class 或其他方式读取

#### 值得注意的是

![image-20200620230723021](../../assets/image-20200620230723021.png)

![image-20200620230744262](../../assets/image-20200620230744262.png)

## 连接

### 连接第1阶段-验证

确保 Class文件符合当前虚拟机的要求,保障虚拟机自身的安全,只有通过验证的 Class 文件才能被 JVM 加载

- 文件格式校验 

  > 验证字节流是否符合 Class 文件规范, 是否是 0xCAFEBABE 开头,主次版本号等等

- 元数据校验

  > 对字节码描述的信息进行语义分析,以保证其描述的信息符合 Java 语言规范的要求
  >
  > 例如, 除了 Object 都应该有父类

- 字节码校验

  > 主要目的是通过数据流分析和控制流分析,确定成语语义是否合法,符合逻辑的

- 符号引用校验

  > 该类是否缺少或者被禁止访问它依赖的某些外部类,方法,字段等资源
  >
  > - 符号引用通过字符串描述的全限定名能否找到对应的类
  >
  > - 指定类里是否包含符合方法的字段描述符以及简单名称锁描述的方法和字段

### 连接第2阶段-准备

主要工作时在方法区中为**类变量分配内存空间**并设置类的变量的初始值

初始值指的是不同数据类型的默认值,这里需要注意 final 类型的变量和非 final类型的变量在准备阶段数据数据初始化过程不同

```java
public static long value = 1000;
```

- 静态变量 value 在准备阶段初始值 0 
- 对象初始化阶段将 value 设置为 1000

这是因为静态变量的初始化操作是定义在构造器中

如果将变量定义为 final 变量

```
public static final int vlaue = 1000;
```

JVM 在编译阶段会为 final 类型的变量 value 生成器对应的 ConstantValue 属性,虚拟机在准备阶段会根据 ConstantValue 属性将 value 设置为 1000

<img src="../../assets/image-20200620233056117.png" alt="image-20200620233056117" style="zoom:50%;" />

## 连接第3阶段-解析

解析阶段的主要做的是 : **JVM 会将常量池中的符号引用替换为直接引用**

符号引用是 Class 文件格式内多次出现的, 以 

- CONSTANT_Class_info
- CONSTANT_Fieldref_info 
- CONSTANT_Methodref_info 

等类型的常量出现

#### 什么是符号引用

符号引用 (Symbolic Reference) :  符号引用以一组符号来描述所引用的目标, 符号可以是**任何形式的字面量** , 只要使用时能无歧义地定位到目标即可

符号引用 与虚拟机实现的内存布局无关,引用目标并不一定是已经加载到虚拟机内存当中的内容

各种虚拟机实现的内存布局可以各不相同, 但是它们能够接受的符号引用必须是一致的, 因为符号引用的字面量形式明确定义在<Java 虚拟机规范> 的 class 文件格式中

#### 什么是直接引用

直接引用(Direct refeerence) : 直接引用时可以直接指向目标的指针、相对偏移量或者是一个能够间接定位到目标的句柄 

**直接引用和虚拟机的内存实现直接相关** 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同, 如果有了直接引用, 那引用的目标必定已经在虚拟机的内存中存在

#### 解析发生的具体时间

java 虚拟机规范 中没有具体规定解析阶段发生的具体时间, 只要求了在执行 ane-warray , checkcast, getfield, getstatic, instanceof, invokebynamic, invokeinterface, invoke-special, invokestatic, ldc, ldc_w, ldc2_2 , multianewarray, new, putfield 和 putstatic  这 17 个用于操作符号引用的字节指令之前,先对他们所使用的符号引用进行解析

所以虚拟机实现可以根据需要来自行判断,到底是在类被加载器加载时就对常量池中的符号引用进行解析,还是等待一个符号引用将要被使用前才会解析它



> ![image-20200620233534054](../../assets/image-20200620233534054.png)
>
> ![image-20200620233622437](../../assets/image-20200620233622437.png)

## 初始化

> `<client>` 方法是由编译器自动收集类中的所有类变量的复制动作和静态语句块 static {} 块 中的语句合并产生的
>
> 编译器的收集顺序是定义顺序
>
> 静态语句块中只能访问到定义在静态语句块之前的变量,定义在它之后的变量,在前面的静态语句块中可以赋值,但是不能访问

主要通过类的构造器`<client>` 方法对类进行初始化,`<client>`方法是编译阶段由编译器自动收集类中的静态语句块和变量的复制操作组成的,在一个类中既没有静态变量复制操作也没有静态语句时,编译器不会为该类生成`<client>`方法,

发生以下几种情况时 , JVM **不会执行类的初始化**

- 常量在编译的时候会将其常量值存入使用该常量类的常量池中,这个过程不需要调用常量所在的类,因此不会触发该常量类的初始化
- 在子类引用父类的静态字段时,不会触发子类的初始化,只会触发父类的初始化
- 定义对象数组,不会触发这个类的初始化
- 在使用类名获取` Class` 对象时,不会触发累的初始化
- 在使用 `Class.forName` 加载指定的类时,可以通过` initialize `参数设置是否需要对类进行初始化
- 在使用 `ClassLoader`默认的` loadClass` 方法加载类的时候不会触发该类的初始化





