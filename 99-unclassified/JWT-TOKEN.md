# JWT token

[TOC]

JWT (JSON WEB TOKEN ) 是一种使用 JSON 格式来规约TOKEN 或者 SESSION 的协议,由于传统认证方式免不了会生成一个凭证,这个凭证可以是 token或者是 session,保存于服务端或者其他持久化工具中,这样一来,凭证的存取就显得非常麻烦,JWT 的出现打破了这个瓶颈,实现了"客户端 SESSION"的愿景

- Header 头部 :  指定 JWT 使用的签名算法
- payload 荷载 :  包含一些自定义与非自定义的认证信息
- signature 签名 : 将头部与载荷使用"."连接,使用头部的签名算法生成签名信息并拼装到末尾

<img src="../assets/jwt.png" alt="img" style="zoom:50%;" />



至此，三个部分，都解释完了，那么按照 header.payload.signature 这个格式串起来就行了，串之前注意，header和payload也要做一个base64url encoded的转换。那么最终拼出来的一个例子是：



```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

### 签名的目的

最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。对于两个不同的输入，产生同样的输出的概率极其地小（有可能比我成世界首富的概率还小）。所以，我们就把“不一样的输入产生不一样的输出”当做必然事件来看待吧。

所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。

服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在JWT的头部中已经用`alg`字段指明了我们的加密算法了。

如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。

### 信息会暴露？

是的。

所以，在JWT中，不应该在载荷里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。

但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。

