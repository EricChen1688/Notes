# Redis 主从复制(replication)

## 目录

- [最终一致性](#最终一致性)
- [主从复制配置](#主从复制配置)

## 最终一致性

Redis 的主从是异步同步的,所以分布式的 Redis 系统并不满足一致性的要求 (AP)

- 当客户端修改了 Redis 主节点上的数据后,立即返回
- 即使在主从网断开的情况下,主节点依然可以正常对外提供修改服务,所以 Redis 满足可用性

Redis 保持最终一致性, 从节点会努力追赶主节点,最终从节点的状态会和主节点的状态保持一致

一旦网络恢复,从节点会用多种策略努力追赶,继续努力保持和主节点一致

## 主从复制配置

例如一主多从,203 是主节点，在每个 slave 节点的 redis.conf 配置文件增加一行,

```
slaveof 192.168.8.203 6379
```

在主从切换的时候，这个配置会被重写成:

```
# Generated by CONFIG REWRITE
replicaof 192.168.8.203 6379
```

或者在启动服务时通过参数指定 master 节点:

```
./redis-server --slaveof 192.168.8.203 6379
```

或在客户端直接执行 slaveof xx xx，使该 Redis 实例成为从节点。

启动后，查看集群状态:

```
redis> info replication
```

从节点不能写入数据(只读)，只能从 master 节点同步数据。get 成功，set 失败。

```
127.0.0.1:6379> set gupao 666
(error) READONLY You can't write against a read only replica.
```

主节点写入后，slave 会自动从 master 同步数据。 断开复制:

```
redis> slaveof no one
```

 此时从节点会变成自己的主节点，不再复制数据。

### docker案例

值得注意的是 docker 中的 --link 选项能保证容器间的通讯

```
docker run --link redis:redis --name console ubuntu bash
```

#### 启动主

```
docker run -d -p 6060:6379 --name redis-master -v /Users/ec/study/redis/6060/data:/data -v /Users/ec/study/redis/6060/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes 

```

#### 启动 slave1

```
docker run -d -p 6070:6379 --link redis-master:master --name redis-slave1 -v /Users/ec/study/redis/6070/data:/data -v /Users/ec/study/redis/6070/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes --slaveof master 6379
```

#### 启动slave2

```
docker run -d -p 6080:6379 --link redis-master:master --name redis-slave2 -v /Users/ec/study/redis/6080/data:/data -v /Users/ec/study/redis/6080/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes   --slaveof master 6379
```

```
slaveof master 6379
```

```
docker run -d -p 6090:6379 --link redis-master:master --name redis-slave3 -v /Users/ec/study/redis/6080/data:/data -v /Users/ec/study/redis/6080/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes --slaveof master 6379
```

