# Redis 主从复制(replication)

## 主从复制配置

例如一主多从,203 是主节点，在每个 slave 节点的 redis.conf 配置文件增加一行,

```
slaveof 192.168.8.203 6379
```

在主从切换的时候，这个配置会被重写成:

```
# Generated by CONFIG REWRITE
replicaof 192.168.8.203 6379
```

或者在启动服务时通过参数指定 master 节点:

```
./redis-server --slaveof 192.168.8.203 6379
```

或在客户端直接执行 slaveof xx xx，使该 Redis 实例成为从节点。

启动后，查看集群状态:

```
redis> info replication
```

从节点不能写入数据(只读)，只能从 master 节点同步数据。get 成功，set 失败。

```
127.0.0.1:6379> set gupao 666
(error) READONLY You can't write against a read only replica.
```

主节点写入后，slave 会自动从 master 同步数据。 断开复制:

```
redis> slaveof no one
```

 此时从节点会变成自己的主节点，不再复制数据。



### doker 案例

值得注意的是 docker 中的 --link 选项能保证容器间的通讯

```
docker run --link redis:redis --name console ubuntu bash
```

#### 启动主

```
docker run -d -p 6060:6379 --name redis-master -v /Users/ec/study/redis/6060/data:/data -v /Users/ec/study/redis/6060/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes 

```

#### 启动 slave1

```
docker run -d -p 6070:6379 --link redis-master:master --name redis-slave1 -v /Users/ec/study/redis/6070/data:/data -v /Users/ec/study/redis/6070/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes --slaveof master 6379
```

#### 启动 slave2

```
docker run -d -p 6080:6379 --link redis-master:master --name redis-slave2 -v /Users/ec/study/redis/6080/data:/data -v /Users/ec/study/redis/6080/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes   --slaveof master 6379
```

```
slaveof master 6379
```

```
docker run -d -p 6090:6379 --link redis-master:master --name redis-slave3 -v /Users/ec/study/redis/6080/data:/data -v /Users/ec/study/redis/6080/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes --slaveof master 6379
```

## 主从复制原理

#### 连接节点

- slave node 启动时, 执行 slaveof 命令,会自己本地保存 master node 的信息,包括 master node 和 host 和 ip
- slave node 内部有一个定时任务,每隔一秒检查是否有新的 master node 要连接和复制
  - 如果有,建立 socket 连接, salve node 会建立一个事件处理器,负责后续的复制工作,如接受 RDB 文件,接受命令传播

#### 数据同步阶段

master node 第一次会执行全量复制:

- 通过 bgsave 命令在本地生成一份 RDB 快照
- 将 RDB 快照发给 slave node , 如果超时会重连(repl-timeout 属性)
- slave node 清除自己的旧数据,然后用 RDB 文件加载数据

**生成 RDB文件期间,master 接收到命令怎么处理?**

开始生成 RDB 文件的时候,master 会把所有新的写命令缓存在内存中,在 slave node 保存 RDB 之后,将新的写命令复制给 salve node

#### 命令传播阶段

master node 持续写命令,异步复制给 salve node

延迟不可避免,只能通过优化网络

```
repl-disable-tcp-nodelay no
```

- 当设置为 yes 时,TCP 会对包进行合并从而减少带宽,但是发送的频率会降低,从节点数据延迟增加,一致性会变差
- 具体发送频率与 Linux 内核的配置有关,默认为 40ms
- 当设置为 no 时, TCP 会立马将主节点的数据发送给从节点,带宽增加但是延迟会变小

一般来说,只有当应用对 Redis 的容忍度较高的时候,且主从接地那之间网络状况不好的情况下,才设置为 yes, 多数情况下设置为 no

**如果从节点有一段时间断开了与主节点的连接是不是要重新全量复制一遍? 如果可以增量复制，怎么知道上次复制到哪里?**

通过 master_repl_offset 记录的偏移量

redis> info replication

##  主从复制的不足

主从模式解决了数据备份和性能(通过读写分离)的问题，但是还是存在一些不足:

- RDB 文件过大的情况下，同步非常耗时。
- 在一主一从或者一主多从的情况下，如果主服务器挂了，对外提供的服务就不可 用了，单点问题没有得到解决。如果每次都是手动把之前的从服务器切换成主服务器， 这个比较费时费力，还会造成一定时间的服务不可用。