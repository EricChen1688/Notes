# Redis 主从复制(replication)

## 最终一致性

Redis 的主从是异步同步的,所以分布式的 Redis 系统并不满足一致性的要求

- 当客户端修改了 Redis 主节点上的数据后,立即返回
- 即使在主从网断开的情况下,主节点依然可以正常对外提供修改服务,所以 Redis 满足可用性

Redis 保持最终一致性, 从节点会努力追赶主节点,最终从节点的状态会和主节点的状态保持一致

一旦网络恢复,从节点会用多种策略努力追赶,继续努力保持和主节点一致



## 主从复制配置

例如一主多从,203 是主节点，在每个 slave 节点的 redis.conf 配置文件增加一行,

```
slaveof 192.168.8.203 6379
```

在主从切换的时候，这个配置会被重写成:

```
# Generated by CONFIG REWRITE
replicaof 192.168.8.203 6379
```

或者在启动服务时通过参数指定 master 节点:

```
./redis-server --slaveof 192.168.8.203 6379
```

或在客户端直接执行 slaveof xx xx，使该 Redis 实例成为从节点。

启动后，查看集群状态:

```
redis> info replication
```

从节点不能写入数据(只读)，只能从 master 节点同步数据。get 成功，set 失败。

```
127.0.0.1:6379> set gupao 666
(error) READONLY You can't write against a read only replica.
```

主节点写入后，slave 会自动从 master 同步数据。 断开复制:

```
redis> slaveof no one
```

 此时从节点会变成自己的主节点，不再复制数据。



### doker 案例

值得注意的是 docker 中的 --link 选项能保证容器间的通讯

```
docker run --link redis:redis --name console ubuntu bash
```

#### 启动主

```
docker run -d -p 6060:6379 --name redis-master -v /Users/ec/study/redis/6060/data:/data -v /Users/ec/study/redis/6060/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes 

```

#### 启动 slave1

```
docker run -d -p 6070:6379 --link redis-master:master --name redis-slave1 -v /Users/ec/study/redis/6070/data:/data -v /Users/ec/study/redis/6070/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes --slaveof master 6379
```

#### 启动 slave2

```
docker run -d -p 6080:6379 --link redis-master:master --name redis-slave2 -v /Users/ec/study/redis/6080/data:/data -v /Users/ec/study/redis/6080/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes   --slaveof master 6379
```

```
slaveof master 6379
```

```
docker run -d -p 6090:6379 --link redis-master:master --name redis-slave3 -v /Users/ec/study/redis/6080/data:/data -v /Users/ec/study/redis/6080/conf/redis.conf:/usr/local/etc/redis/redis.conf redis:5.0 --appendonly yes --slaveof master 6379
```

## 主从复制原理

> - 增量同步
> - 快照同步
>
> #### 增量同步
>
> Redis 是指令流,主节点将那些对自己状态产生修改性影响的指令记录在本地的内存 buffer 中,然后异步将 buffer 中的指令同步到从节点,从节点一边执行同步指令流来达到和主节点一样的状态,一边向主节点反馈自己同步到哪里了(通过偏移量)
>
> 因为内存的 buffer优先,所以 Redis 主节点不能将所有的指令都记录在内存 buffer 中
>
> Redis 的复制内存 buffer 是一个定长的环型数组,如果数组内容满了,就会从头开始覆盖前面的内容
>
> 如果因为网络状态不好,从节点在短时间内无法和主节点进行同步,那么当网络状态恢复时,Redis 主节点中哪些没有同步的指令在 buffer 中有可能被后续的指令覆盖掉,从节点无法直接通过指令流来进行同步,这个时候就要用到快照同步
>
> #### [快照同步](#数据同步阶段)
>
> 

#### 连接阶段

- slave node 启动时, 执行 slaveof 命令,会自己本地保存 master node 的信息,包括 master node 和 host 和 ip
- slave node 内部有一个定时任务,每隔一秒检查是否有新的 master node 要连接和复制
  - 如果有,建立 socket 连接, salve node 会建立一个事件处理器,负责后续的复制工作,如接受 RDB 文件,接受命令传播

#### 

#### 数据同步阶段

master node 第一次会执行全量复制:

- 通过 bgsave 命令在本地生成一份 RDB 快照
- 将 RDB 快照发给 slave node , 如果超时会重连(repl-timeout 属性)
- slave node 清除自己的旧数据,然后用 RDB 文件加载数据

**生成 RDB文件期间,master 接收到命令怎么处理?**

开始生成 RDB 文件的时候,master 会把所有新的写命令缓存在内存中,在 slave node 保存 RDB 之后,将新的写命令复制给 salve node

#### 命令传播阶段

master node 持续写命令,异步复制给 salve node

延迟不可避免,只能通过优化网络

```
repl-disable-tcp-nodelay no
```

- 当设置为 yes 时,TCP 会对包进行合并从而减少带宽,但是发送的频率会降低,从节点数据延迟增加,一致性会变差
- 具体发送频率与 Linux 内核的配置有关,默认为 40ms
- 当设置为 no 时, TCP 会立马将主节点的数据发送给从节点,带宽增加但是延迟会变小

一般来说,只有当应用对 Redis 的容忍度较高的时候,且主从接地那之间网络状况不好的情况下,才设置为 yes, 多数情况下设置为 no

**如果从节点有一段时间断开了与主节点的连接是不是要重新全量复制一遍? 如果可以增量复制，怎么知道上次复制到哪里?**

通过 master_repl_offset 记录的偏移量

redis> info replication

#### 数据同步阶段

- master node 第一次执行全量复制, 通常使用 bgsave 在本地生成一份 RDB 快照
- 将 RDB快照发给 slave node (如果超时会重连,可以调大 repl-timeout)
- slave node 首先清除自己的旧数据,然后用 RBD 加载数据

> 问题:生成 RDB 期间，master 接收到的命令怎么处理?
> 开始生成 RDB 文件时，master 会把所有新的写命令缓存在内存中。在 slave node 保存了 RDB 之后，再将新的写命令复制给 slave node。

> **快照复制死循环问题**
>
> 在整个快照同步进行的过程中,主节点的复制 buffer 还在不停的向前移动,如果同步时间过长或者复制 buffer 过小,都会导致同步期间的增量指令在复制 buffer 中被覆盖,这样就导致快照同步完成之后无法进行增量复制,然后再次发起快照同步,有可能会陷入死循环
>
> 一定要设置一个合适的 buffer 大小,避免快照复制的死循环

#### 命令传播阶段

master node 持续将写命令，异步复制给 slave node

延迟是不可避免的，只能通过优化网络。

> repl-disable-tcp-nodelay no

当设置为 yes 时，TCP 会对包进行合并从而减少带宽，但是发送的频率会降低，从 节点数据延迟增加，一致性变差;具体发送频率与 Linux 内核的配置有关，默认配置为 40ms。

当设置为 no 时，TCP 会立马将主节点的数据发送给从节点，带宽增加但延迟变 小。

一般来说，只有当应用对 Redis 数据不一致的容忍度较高，且主从节点之间网络状 况不好时，才会设置为 yes;多数情况使用默认值 no。



> 问题:如果从节点有一段时间断开了与主节点的连接是不是要重新全量复制一遍? 如果可以增量复制，怎么知道上次复制到哪里?

master_repl_offset 记录的偏移量

```
redis> info replication
```

##  主从复制的不足

主从模式解决了数据备份和性能(通过读写分离)的问题，但是还是存在一些不足:

- RDB 文件过大的情况下，同步非常耗时。
- 在一主一从或者一主多从的情况下，如果主服务器挂了，对外提供的服务就不可 用了，单点问题没有得到解决。如果每次都是手动把之前的从服务器切换成主服务器， 这个比较费时费力，还会造成一定时间的服务不可用。

#### 无盘复制

主节点在进行快照同步时,会进行很耗时的文件 IO 操作,在非 SSD磁盘存储时,快照同步会对系统的负载产生较大影响,特别是当系统正在进行 AOF的 fsync 操作时,如果发生快照同步,fsync 将会被推迟执行,这样就会严重影响主节点的服务效率

所以需要无盘复制

主服务器一边遍历内存,一边将序列化的内容发给从节点,从节点还是跟以前一样,先接收到再存储到硬盘

#### wait 指令

wait 指令可以让一步复制变身为同步复制,确保系统的强一致性(不严格)

wait 指令时 Redis3.0 版本以后才出来的

```
set key value 
wait 1 0

```

- 第一个参数是从节点的数量 N, 

- 第二个参数是时间 t,以毫秒为单位

等待 wait 指令之前的所有写操作同步到 N个从节点上, 也就是确保 N 个节点的同步没有之后,最多等待 t 时间,如果 t=0 标识无线等待到 N 个从节点同步完成

> 假设这个时候出现网络分区,wait 指令第二个参数时间 t=0 会导致主从同步无法继续进行,wait 指令会永远在阻塞,Redis 会丧失一致性





