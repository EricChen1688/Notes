# 限流

- 简单限流

- 漏斗限流



## 简单限流

系统要先定用户的某个行为在规定的事件内只能发生 N 次,使用 **滑动时间窗口**,

我们可以使用 zset 数据结构来实现

- key 用户行为的唯一约束
- score 存放时间涌口

为了节省内存,我们只需要保留时间窗口内的行为记录,如果是冷用户,**滑动窗口**内的行为是空记录,就可以从 zset 中移除

通过统计滑动窗口内的行为数量和阈值 max_count 进行比较就可以得到当前行为是否被允许

```java
/**
 * <p>
 * 滑动窗口简单实现限流
 * </p>
 *
 * @author ericchen.vip@foxmail.com 2020/04/18 21:37
 */
@Component("simpleRateLimiter")
public class SimpleRateLimiter implements IRateLimiter {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;


    @Override
    public boolean isActionAllowed(String userId, String actionKey, int period, int maxCount) {
        String key = String.format("hist:%s:%s", userId, actionKey);
        long nowTs = System.currentTimeMillis();
        List answer = redisTemplate.executePipelined((RedisCallback<List>) connection -> {
            connection.multi();
            byte[] keyBytes = key.getBytes();
            connection.zAdd(keyBytes, nowTs, ("" + nowTs).getBytes()); //score 是当前时间 ,value没有特别意义,可以随便设置
            connection.zRemRangeByScore(keyBytes, 0, nowTs - period * 1000);//清除 0-60 秒之前的数据
            connection.zCard(keyBytes);//判断剩余的个数]
            connection.expire(keyBytes, period + 1L);//失效
            return connection.exec();
        });
        if (CollectionUtils.isEmpty(answer)) {
            return false;
        }
        List o = (List) answer.get(0);
        if (o != null && o.size() > 3) {
            Long o1 = (Long) o.get(2);
            return o1 <= maxCount;
        }
        return false;
    }
  }
```

#### 缺点

- 在记录时间窗口内的所有行为记录,如果量很大,那么不适合,比如"60 秒之内不能操作 100万次"

## 漏斗限流

每次灌水前都会调用 makespace 触发漏水,给漏斗腾出空间,能腾出多少空间取决于过去了多久以及流水的速率

```java
/**
 * <p>
 * 漏斗限流
 * </p>
 *
 * @author ericchen.vip@foxmail.com 2020/04/18 23:25
 */
public class FunnelRateLimiter implements IRateLimiter {
    private Map<String, Funnel> funnelMap = new ConcurrentHashMap<>();

    @Override
    public boolean isActionAllowed(String userId, String actionKey, int capacity, float leakingRate) {
        String key = String.format("%s,%s", userId, actionKey);
        Funnel funnel = funnelMap.get(actionKey);
        if (funnel == null) {
            funnel = new Funnel(capacity, leakingRate);
            funnelMap.put(key, funnel);
        }
        return funnel.watering(1);
    }

    static class Funnel {
        int capacity; //漏斗容量
        float leakingRate; // 漏嘴流水速率
        int leftQuota;//漏斗剩余空间
        long leakingTs;//上一次漏水时间

        public Funnel(int capacity, float leakingRate) {
            this.capacity = capacity;
            this.leakingRate = leakingRate;
            this.leftQuota = capacity;
            this.leakingTs = System.currentTimeMillis();
        }

        void makeSpace() {
            long nowTs = System.currentTimeMillis();
            long deltaTs = nowTs - leakingTs;
            int deltaQuota = (int) (deltaTs * leakingRate);
            //间隔时间太长
            if (deltaQuota < 0) {
                this.leftQuota = capacity;
                this.leakingTs = nowTs;
                return;
            }
            if (deltaQuota < 1) {
                return;
            }
            this.leftQuota += deltaQuota;
            this.leakingTs = nowTs;
            if (this.leftQuota > this.capacity) {
                this.leftQuota = this.capacity;
            }
        }

        boolean watering(int quota) {
            makeSpace();
            if (this.leftQuota >= quota) {
                this.leftQuota -= quota;
                return true;
            }
            return false;
        }

    }


}

```

## Redis-call

redis4.0提供了限流模块,提供了原子的限流指令

```
cl.throttle key 15 30 60 1 
15: 漏斗容量
30: 30操作
60: 60秒内
1:需要一个容量
```

含义是: 没 60s 最多 30 次(流水速率) , 漏斗初始容量是 15, 一开始可以连续恢复 15 个帖子,然后开始受到漏水速率的影响

返回

```
0//0标识允许,1 标识拒绝
15//漏斗容量
14// 漏斗剩余空间
-1//如果被拒绝了,需要多长时间后再试.单位秒
2// 多长时间后,漏斗完全空出来(leftQuota == capacity,单位秒)

```

