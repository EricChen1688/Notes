# 位图

我们平时在开发过程中,会有一些 bool 类型的数据需要存取, 比如用户一年的签到记录,签了就是 1 , 不签就是 0 ,要记录 365 天,

如果是普通的 key-value 存储,每个用户都要记录 365 个,当用户数上亿的时候,需要的存储空间是惊人的

为了解决这个问题,Redis 提供了位图这个数据结构,这样每天的迁到记录只占据一个位,365 天就是 365 位,46 个字节就可以完全容纳下,这点内存也就是稍微长一点的字符串大大节约了存储空间

**位图的最小单位是 bit , 每个 bit 的取值只能是 0 或者 1 **

## 数据结构

位图的数据结构并不是特殊的数据结构, 它的内容其实就是普通的字符串,也就是 byte 数组

我们可以用 get/ set 方法直接获取和设置整个位图的内容,也可以使用位图操作 getbit/setbit 等将 byte 数组看成"位数组"来处理

## SETBIT key offset value

> 可用版本： >= 2.2.0
>
> 时间复杂度: O(1)

对 `key` 所储存的字符串值，设置或清除指定偏移量上的位(bit)。

位的设置或清除取决于 `value` 参数，可以是 `0` 也可以是 `1` 。

当 `key` 不存在时，自动生成一个新的字符串值。

字符串会进行伸展(grown)以确保它可以将 `value` 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 `0` 填充。

`offset` 参数必须大于或等于 `0` ，小于 2^32 (bit 映射被限制在 512 MB 之内)。

Warning

对使用大的 `offset` 的 [SETBIT](http://redisdoc.com/bitmap/setbit.html#setbit) 操作来说，内存分配可能造成 Redis 服务器被阻塞。具体参考 [SETRANGE key offset value](http://redisdoc.com/string/setrange.html#setrange) 命令，warning(警告)部分。

#### 返回值

指定偏移量原来储存的位。

#### 代码示例

```
redis> SETBIT bit 10086 1
(integer) 0

redis> GETBIT bit 10086
(integer) 1

redis> GETBIT bit 100   # bit 默认被初始化为 0
(integer) 0
```

## BITCOUNT key [start] [end]

> 可用版本： >= 2.6.0
>
> 时间复杂度： O(N)

计算给定字符串中，被设置为 `1` 的比特位的数量。

一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 `start` 或 `end` 参数，可以让计数只在特定的位上进行。

`start` 和 `end` 参数的设置和 [GETRANGE key start end](http://redisdoc.com/string/getrange.html#getrange) 命令类似，都可以使用负数值： 比如 `-1` 表示最后一个字节， `-2` 表示倒数第二个字节，以此类推。

不存在的 `key` 被当成是空字符串来处理，因此对一个不存在的 `key` 进行 `BITCOUNT` 操作，结果为 `0` 。

#### 返回值

被设置为 `1` 的位的数量。

#### 代码示例

```
redis> BITCOUNT bits
(integer) 0

redis> SETBIT bits 0 1          # 0001
(integer) 0

redis> BITCOUNT bits
(integer) 1

redis> SETBIT bits 3 1          # 1001
(integer) 0

redis> BITCOUNT bits
(integer) 2
```

#### 模式：使用 bitmap 实现用户上线次数统计

Bitmap 对于一些特定类型的计算非常有效。

假设现在我们希望记录自己网站上的用户的上线频率，比如说，计算用户 A 上线了多少天，用户 B 上线了多少天，诸如此类，以此作为数据，从而决定让哪些用户参加 beta 测试等活动 —— 这个模式可以使用 [SETBIT key offset value](http://redisdoc.com/bitmap/setbit.html#setbit) 和 [BITCOUNT key [start\] [end]](http://redisdoc.com/bitmap/bitcount.html#bitcount) 来实现。

比如说，每当用户在某一天上线的时候，我们就使用 [SETBIT key offset value](http://redisdoc.com/bitmap/setbit.html#setbit) ，以用户名作为 `key` ，将那天所代表的网站的上线日作为 `offset` 参数，并将这个 `offset` 上的为设置为 `1` 。

举个例子，如果今天是网站上线的第 100 天，而用户 peter 在今天阅览过网站，那么执行命令 `SETBIT peter 100 1` ；如果明天 peter 也继续阅览网站，那么执行命令 `SETBIT peter 101 1` ，以此类推。

当要计算 peter 总共以来的上线次数时，就使用 [BITCOUNT key [start\] [end]](http://redisdoc.com/bitmap/bitcount.html#bitcount) 命令：执行 `BITCOUNT peter` ，得出的结果就是 peter 上线的总天数。

更详细的实现可以参考博文(墙外) [Fast, easy, realtime metrics using Redis bitmaps](http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/) 。

## 性能

前面的上线次数统计例子，即使运行 10 年，占用的空间也只是每个用户 10*365 比特位(bit)，也即是每个用户 456 字节。对于这种大小的数据来说， [BITCOUNT key [start\] [end]](http://redisdoc.com/bitmap/bitcount.html#bitcount) 的处理速度就像 [GET key](http://redisdoc.com/string/get.html#get) 和 [INCR key](http://redisdoc.com/string/incr.html#incr) 这种 O(1) 复杂度的操作一样快。

如果你的 bitmap 数据非常大，那么可以考虑使用以下两种方法：

1. 将一个大的 bitmap 分散到不同的 key 中，作为小的 bitmap 来处理。使用 Lua 脚本可以很方便地完成这一工作。
2. 使用 [BITCOUNT key [start\] [end]](http://redisdoc.com/bitmap/bitcount.html#bitcount) 的 `start` 和 `end` 参数，每次只对所需的部分位进行计算，将位的累积工作(accumulating)放到客户端进行，并且对结果进行缓存 (caching)。

## BITPOS key bit [start] [end]

> 可用版本： >= 2.8.7
>
> 时间复杂度： O(N)，其中 N 为位图包含的二进制位数量

返回位图中第一个值为 `bit` 的二进制位的位置。

在默认情况下， 命令将检测整个位图， 但用户也可以通过可选的 `start` 参数和 `end` 参数指定要检测的范围。

#### 返回值

整数回复。

#### 代码示例

```
127.0.0.1:6379> SETBIT bits 3 1    # 1000
(integer) 0

127.0.0.1:6379> BITPOS bits 0
(integer) 0

127.0.0.1:6379> BITPOS bits 1
(integer) 3
```

## BITOP operation destkey key [key …]

> 可用版本： >= 2.6.0
>
> 时间复杂度： O(N)

对一个或多个保存二进制位的字符串 `key` 进行位元操作，并将结果保存到 `destkey` 上。

`operation` 可以是 `AND` 、 `OR` 、 `NOT` 、 `XOR` 这四种操作中的任意一种：

- `BITOP AND destkey key [key ...]` ，对一个或多个 `key` 求逻辑并，并将结果保存到 `destkey` 。
- `BITOP OR destkey key [key ...]` ，对一个或多个 `key` 求逻辑或，并将结果保存到 `destkey` 。
- `BITOP XOR destkey key [key ...]` ，对一个或多个 `key` 求逻辑异或，并将结果保存到 `destkey` 。
- `BITOP NOT destkey key` ，对给定 `key` 求逻辑非，并将结果保存到 `destkey` 。

除了 `NOT` 操作之外，其他操作都可以接受一个或多个 `key` 作为输入。

#### 处理不同长度的字符串

当 [BITOP](http://redisdoc.com/bitmap/bitop.html#bitop) 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 `0` 。

空的 `key` 也被看作是包含 `0` 的字符串序列。

#### 返回值

保存到 `destkey` 的字符串的长度，和输入 `key` 中最长的字符串长度相等。

Note

[BITOP](http://redisdoc.com/bitmap/bitop.html#bitop) 的复杂度为 O(N) ，当处理大型矩阵(matrix)或者进行大数据量的统计时，最好将任务指派到附属节点(slave)进行，避免阻塞主节点。

#### 代码示例

```
redis> SETBIT bits-1 0 1        # bits-1 = 1001
(integer) 0

redis> SETBIT bits-1 3 1
(integer) 0

redis> SETBIT bits-2 0 1        # bits-2 = 1011
(integer) 0

redis> SETBIT bits-2 1 1
(integer) 0

redis> SETBIT bits-2 3 1
(integer) 0

redis> BITOP AND and-result bits-1 bits-2
(integer) 1

redis> GETBIT and-result 0      # and-result = 1001
(integer) 1

redis> GETBIT and-result 1
(integer) 0

redis> GETBIT and-result 2
(integer) 0

redis> GETBIT and-result 3
(integer) 1
```

## BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]

> 可用版本： >= 3.2.0
>
> 时间复杂度： 每个子命令的复杂度为 O(1) 。

`BITFIELD` 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组， 并对这个数组中储存的长度不同的整数进行访问 （被储存的整数无需进行对齐）。 换句话说， 通过这个命令， 用户可以执行诸如 “对偏移量 1234 上的 5 位长有符号整数进行设置”、 “获取偏移量 4567 上的 31 位长无符号整数”等操作。 此外， `BITFIELD` 命令还可以对指定的整数执行加法操作和减法操作， 并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。

`BITFIELD` 命令可以在一次调用中同时对多个位范围进行操作： 它接受一系列待执行的操作作为参数， 并返回一个数组作为回复， 数组中的每个元素就是对应操作的执行结果。

比如以下命令就展示了如何对位于偏移量 100 的 8 位长有符号整数执行加法操作， 并获取位于偏移量 0 上的 4 位长无符号整数：

```
> BITFIELD mykey INCRBY i8 100 1 GET u4 0
1) (integer) 1
2) (integer) 0
```

注意：

- 使用 `GET` 子命令对超出字符串当前范围的二进制位进行访问（包括键不存在的情况）， 超出部分的二进制位的值将被当做是 0 。
- 使用 `SET` 子命令或者 `INCRBY` 子命令对超出字符串当前范围的二进制位进行访问将导致字符串被扩大， 被扩大的部分会使用值为 0 的二进制位进行填充。 在对字符串进行扩展时， 命令会根据字符串目前已有的最远端二进制位， 计算出执行操作所需的最小长度。

#### 支持的子命令以及数字类型

以下是 `BITFIELD` 命令支持的子命令：

- `GET ` —— 返回指定的二进制位范围。
- `SET  ` —— 对指定的二进制位范围进行设置，并返回它的旧值。
- `INCRBY  ` —— 对指定的二进制位范围执行加法操作，并返回它的旧值。用户可以通过向 `increment` 参数传入负值来实现相应的减法操作。

除了以上三个子命令之外， 还有一个子命令， 它可以改变之后执行的 `INCRBY` 子命令在发生溢出情况时的行为：

- `OVERFLOW [WRAP|SAT|FAIL]`

当被设置的二进制位范围值为整数时， 用户可以在类型参数的前面添加 `i` 来表示有符号整数， 或者使用 `u` 来表示无符号整数。 比如说， 我们可以使用 `u8` 来表示 8 位长的无符号整数， 也可以使用 `i16` 来表示 16 位长的有符号整数。

`BITFIELD` 命令最大支持 64 位长的有符号整数以及 63 位长的无符号整数， 其中无符号整数的 63 位长度限制是由于 Redis 协议目前还无法返回 64 位长的无符号整数而导致的。

#### 二进制位和位置偏移量

在二进制位范围命令中， 用户有两种方法来设置偏移量：

- 如果用户给定的是一个没有任何前缀的数字， 那么这个数字指示的就是字符串以零为开始（zero-base）的偏移量。
- 另一方面， 如果用户给定的是一个带有 `#` 前缀的偏移量， 那么命令将使用这个偏移量与被设置的数字类型的位长度相乘， 从而计算出真正的偏移量。

比如说， 对于以下这个命令来说：

```
BITFIELD mystring SET i8 #0 100 i8 #1 200
```

命令会把 `mystring` 键里面， 第一个 `i8` 长度的二进制位的值设置为 `100` ， 并把第二个 `i8` 长度的二进制位的值设置为 `200` 。 当我们把一个字符串键当成数组来使用， 并且数组中储存的都是同等长度的整数时， 使用 `#` 前缀可以让我们免去手动计算被设置二进制位所在位置的麻烦。

#### 溢出控制

用户可以通过 `OVERFLOW` 命令以及以下展示的三个参数， 指定 `BITFIELD` 命令在执行自增或者自减操作时， 碰上向上溢出（overflow）或者向下溢出（underflow）情况时的行为：

- `WRAP` ： 使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。 对于无符号整数来说， 回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算， 这也是 C 语言的标准行为。 对于有符号整数来说， 上溢将导致数字重新从最小的负数开始计算， 而下溢将导致数字重新从最大的正数开始计算。 比如说， 如果我们对一个值为 `127` 的 `i8` 整数执行加一操作， 那么将得到结果 `-128` 。
- `SAT` ： 使用饱和计算（saturation arithmetic）方法处理溢出， 也即是说， 下溢计算的结果为最小的整数值， 而上溢计算的结果为最大的整数值。 举个例子， 如果我们对一个值为 `120` 的 `i8` 整数执行加 `10` 计算， 那么命令的结果将为 `i8` 类型所能储存的最大整数值 `127` 。 与此相反， 如果一个针对 `i8` 值的计算造成了下溢， 那么这个 `i8` 值将被设置为 `-127` 。
- `FAIL` ： 在这一模式下， 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算， 并向用户返回空值表示计算未被执行。

需要注意的是， `OVERFLOW` 子命令只会对紧随着它之后被执行的 `INCRBY` 命令产生效果， 这一效果将一直持续到与它一同被执行的下一个 `OVERFLOW` 命令为止。 在默认情况下， `INCRBY` 命令使用 `WRAP` 方式来处理溢出计算。

以下是一个使用 `OVERFLOW` 子命令来控制溢出行为的例子：

```
> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 1
2) (integer) 1

> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 2
2) (integer) 2

> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 3
2) (integer) 3

> BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 0  -- 使用默认的 WRAP 方式处理溢出
2) (integer) 3  -- 使用 SAT 方式处理溢出
```

而以下则是一个因为 `OVERFLOW FAIL` 行为而导致子命令返回空值的例子：

```
> BITFIELD mykey OVERFLOW FAIL incrby u2 102 1
1) (nil)
```

#### 作用

`BITFIELD` 命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存， 从而非常高效地使用内存， 使得 Redis 能够得到更多不同的应用 —— 特别是在实时分析领域： `BITFIELD` 能够以指定的方式对计算溢出进行控制的能力， 使得它可以被应用于这一领域。

#### 性能注意事项

`BITFIELD` 在一般情况下都是一个快速的命令， 需要注意的是， 访问一个长度较短的字符串的远端二进制位将引发一次内存分配操作， 这一操作花费的时间可能会比命令访问已有的字符串花费的时间要长。

#### 二进制位的排列

`BITFIELD` 把位图第一个字节偏移量 0 上的二进制位看作是 most significant 位， 以此类推。 举个例子， 如果我们对一个已经预先被全部设置为 0 的位图进行设置， 将它在偏移量 7 的值设置为 5 位无符号整数值 23 （二进制位为 `10111` ）， 那么命令将生产出以下这个位图表示：

```
+--------+--------+
|00000001|01110000|
+--------+--------+
```

当偏移量和整数长度与字节边界进行对齐时， `BITFIELD` 表示二进制位的方式跟大端表示法（big endian）一致， 但是在没有对齐的情况下， 理解这些二进制位是如何进行排列也是非常重要的。

#### 返回值

`BITFIELD` 命令的返回值是一个数组， 数组中的每个元素对应一个被执行的子命令。 需要注意的是， `OVERFLOW` 子命令本身并不产生任何回复。