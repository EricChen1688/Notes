# Scan

key的缺点:

- 遍历算法,时间复杂度 O(n)
- 因为 Redis 是单线程,所有使用key 会影响性能
- 没有分页参数

## Scan

- 复杂度 O(n), 但是通过游标分步进行,不会阻塞线程
- 提供 limit 参数,每次返回结果的最大条数 ,limit 只是一个 hint 返回结果可以多可以少
- 提供模式匹配
- 服务端不需要为游标保存状态,游标的唯一状态就是 scan返回给客户端的游标证书
- 返回的结果可能有重复,需要客户端去重,这个非常重要
- 遍历过程中如果有数据修改,改动后的数据能不能遍历到不确定
- 单次返回结果是空并不意味着建立结束,而要看返回的游标值是否为零

```
127.0.0.1:6379> scan 0 match key99* count 1000
1) "100672"
2) 1) "key99073"
   2) "key99130"
   3) "key99638"
   4) "key99039"
   5) "key99193"
127.0.0.1:6379> scan 0 match key99* count 100
1) "57856"
2) (empty list or set)
127.0.0.1:6379> scan 0 match key99* count 10
1) "118784"
2) (empty list or set)
127.0.0.1:6379> scan 0 match key99* count 1
```



- limit 不是先定返回结果的数量,而是遍历了多少个槽位

## Redis 中的 大key

有时候 Redis 使用不当,会形成一个非常大的 hash或者很大的 zset, 这种 key 就属于大 key

大 key 在进行集群数据迁移的时候会带来很多问题

- 集群下, 如果某个 key 太大,会导致数据迁移卡顿
- 在内存分配上,如果一个 key很大,那么当它需要扩容时,会一次性申请更大的一块内存,也会导致卡顿
- 如果这个大 key 被删除,内存会被一次性回收,也会产生

简而言之就是

- 迁移卡
- 扩容卡
- 回收卡

#### 系统出现大 key 的症状

- Redis 内存大起大落,很有可能是大 key 导致的这个时候就得具体定位是哪个 key

#### 定位大 key

```
redis-cli --bigkeys 
```

如果你担心指令会大幅抬升 Redis Ops ,导致线上报警,还可以加一个休眠参数

```
redis-cli -h 127.0.0.1 -p 7001 --bigkeys -i 0.1

```

每隔 100 条 scan 会休眠 0.1s , ops (operation per second ) 不会大幅度抬升



