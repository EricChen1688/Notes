# Scan

key的缺点:

- 遍历算法,时间复杂度 O(n)
- 没有 offset , limit 参数,一次性会返回所有符合条件的key
- 因为 Redis 是单线程,所有使用key 会影响性能
- 没有分页参数

## Scan

- 复杂度也是 O(n), 但是通过游标分步进行,不会阻塞线程
- 提供 limit 参数, 限定服务器单次遍历字典槽位数,而不是限定返回的结果数量
- 服务端不需要为游标保存状态,游标的唯一状态就是 scan返回给客户端的游标证书
- 返回的结果可能有重复,需要客户端去重,这个非常重要
- 遍历过程中如果有数据修改,改动后的数据能不能遍历到不确定
- 单次返回结果是空并不意味着建立结束,而要看返回的游标值是否为零

```
127.0.0.1:6379> scan 0 match key99* count 1000
1) "100672"
2) 1) "key99073"
   2) "key99130"
   3) "key99638"
   4) "key99039"
   5) "key99193"
127.0.0.1:6379> scan 0 match key99* count 100
1) "57856"
2) (empty list or set)
127.0.0.1:6379> scan 0 match key99* count 10
1) "118784"
2) (empty list or set)
127.0.0.1:6379> scan 0 match key99* count 1
```

## Scan 遍历顺序

Redis 中所有的 key 都存储在一个很大的字典里,这个字典的结构和 Java 中的 hashmap 很像,

数组+链表 的结构实现的

- 一维数组总是 2^n (n>=0)
- 扩容一次数组,大小空间加倍 ,也就是 2^(n+1)

scan 指令返回的游标就是一维数组的位置索引,我们将这个位置索引成为槽(slot)

如果不考虑字典的扩容缩容,直接按照数组下标挨个遍历就行了

limit 参数就是要遍历的槽位数

**之所以返回的结果可能多可能少**,是因为不是所有的槽位上都挂接链表,有些槽位有可能是空的,还有些操作上挂接的元素可能有多个,所以每次遍历都会将 limit 数组的槽位上挂接所有链表元素进行模式匹配后过滤

一次性返回给客户端

##### 遍历顺序

scan 的遍历顺序非常特别,他不是从第一维数组的第 0 位一直遍历到末尾,而是采用了高进位加法来遍历

> 之所以采用这种特殊的方式遍历,是考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏

普通加法

```
0000   +1   =  0001 ; 
0001   +1   =  0010 ;
0010   +1   =  0011 ;
```

高进位加法

```
0000   +1   = 1000;
1000   +1   = 0100;
0100   +1   = 1100;
```

从高位遍历是考虑到避免槽位的遍历重复和一口







