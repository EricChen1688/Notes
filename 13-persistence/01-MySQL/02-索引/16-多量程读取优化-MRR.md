# 多量程读取优化-MRR

Muti-Range Read Optimization  简称 MR优化

## 目的

MRR 的优化就是为了减少磁盘的随机访问,并且将随机访问转化较为顺序的数据访问 , 这对于 IO-bound 类型的 SQL 语句带来性能极大的提升

muti-range-read 优化可适用于 range , ref,  eq_ref 类型的查询

## 好处

- MRR 使 数据访问变得较为顺序, 在查询辅助索引的时候, 首先根据得到的查询结果,按照主键进行排序,并按照主键排序的顺序进行书签查找
- 减少缓冲池中页被替换的次数
- 批量处理对键值的查询操作

对于 InnoDB 和 MyISAM 存储引擎的范围查询 和 JOIN 查询, MRR 的工作方式如下

- 将查询得到的辅助索引的值存放于一个缓冲中,这时缓冲中的数据是根据辅助索引值排序的
- 将缓冲中的键值根据 RowID 进行排序
- 根据 RowId 的排序顺序来访问实际的数据文件

此外, 如果 InnoDB 存储引擎或者 MyISAM 存储引擎的缓冲池不是足够大,即不能放下一张表中的所有数据,此时频繁地离散度操作还会导致缓存中的页被替换出缓冲池,然后又不断地被读入缓冲池

若是按照主键顺序进行访问, 则可以将此重复行为降为最低

## 例子

比如下面这个 sql

```

```





## 参数

- mrr

- mrr_cost_based

  > 表示是否通过基于成本的算法来确定开始 mrr 特性,
  >
  > - 设置为 on 表示自行判断
  > - off 表示强制开启 mrr

```
show variables like 'optimizer_switch';
```

```
...
mrr=on,mrr_cost_based=on,
...
```

## 原理

MRR 的原理很简单, MySQL 普通索引获取数据的方式,显示通过索引页的叶子节点找到对应的主键,再通过主键找到相对应的行数据记录, 

- 如果在一张表中对某一个字段创建一个普通索引,单这个字段有一些重复的值,那么根据这个字段取做 where 条件时, 每次去到的主键值可能不是按照顺序的,那么随机 IO 的行为就会发生
- MRR 的作用就是把呕吐索引的叶子节点上找到的主键值的集合存储到 read_rnd_buffer 中,然后再改该 buffer 中对主键值进行排序,最后再利用已经排序好的主键值的集合,去访问表中的数据,这样就由原来的随机 IO 变成了顺序 IO,降低了 Io 的查询开销

> 在生产环境中,read_rnd_buffer_size 的值可以是 4~8MB之间调整