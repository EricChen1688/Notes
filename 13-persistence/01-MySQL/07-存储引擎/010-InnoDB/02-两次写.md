# 两次写(Double Write)

#### 一句话总结

> 如果说 ChangeBuffer 带给 InnoDB 存储引擎的是性能上的提升,那么 Double Write 两次写带给 InnoDB 存储引擎的是数据页的可靠性

## 目录

- [为什么要保证数据页的可靠性](#为什么要保证数据页的可靠性)
- [DoubleWrite的结构](#DoubleWrite的结构)
- [工作流程](#工作流程)

## 为什么要保证数据页的可靠性

#### 部分写失败

当发生数据库宕机时,可能 InnoDB 存储引擎正在写入某个页到表中,而这个页只写了一部分, 比如 16KB 的页, 只写了前 4KB ,就发生了宕机,这种情况被成为**部分写失效(partial page write)** 

在 InnoDB 存储引擎没有使用 DoubleWrite 技术之前,曾经出现过因为部分写失败而导致数据丢失的情况

#### 为什么不能用 redolog 来恢复呢

当数据库实例崩溃时, 使用 redolog 进行恢复,不会有任何问题,但是如果 **redolog 文件记录的是页的物理地址, 如果页都损坏了,是无法进行任何恢复操作的**

## DoubleWrite的结构

由两部分组成

- 一部分是内存中的 double write buffer , 大小为 2MB
- 一部分是在物理磁盘上共享表空间中的,连续 128 个页, 2 个区 ,大小 同样是 2MB

![image-20200824132806563](../../../../assets/image-20200824132806563.png)

## 流程

- 缓冲池准备对脏页进行刷脏, 还没有写磁盘

- 通过 memcpy 函数将脏页复制到内存中的 doublewrite buffer (大小是 2M) 

  > doublewrite 页是连续的,因此这个过程是顺序写的,开销不是很大

- 调用 fync 函数 同步脏页到磁盘

崩溃恢复

- InnoDB 引擎先从共享表空间中的 doublewrite 中找到该页的一个副本
- 将副本复制到表空间文件
- 执行 redo log

## 工作流程

双写缓冲是一个位于系统表空间中的**存储区域**

- 在堆缓冲池的脏页进行刷新时,并不直接写磁盘,而是会通过 memcpy 函数将脏页先复制到 doublewrite buffer 中

- 之后通过 doublewrite buffer 再分两次,每次 1MB 顺序地写入共享空间的物理磁盘上
- 调用 fsync 函数,同步磁盘,避免缓冲写带来的问题(这个过程是顺序写的,开销并不是很大)

完成doublewrite 页的写入后,再将 doublewrite buffer 中的页写入各个表空间文件中, 此时写入则是离散的

## 配置

双写缓冲在默认场景下都是有效的,可以通过设置 **innodb_doublewrite** 为 0 来关闭双写缓冲

