# QA-Redis

> 1.Redis支持的数据类型？
>
> 2.什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？
>
> 3.Redis 有哪些架构模式？讲讲各自的特点
>
> 4.使用过Redis分布式锁么，它是怎么实现的？
>
> 5.使用过Redis做异步队列么，你是怎么用的？有什么缺点？
>
> 6.什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？
>
> 7.Redis常用命令
>
> 8.为什么Redis 单线程却能支撑高并发？
>
> 9.说说Redis的内存淘汰策略
>
> 10.Redis的并发竞争问题如何解决?

- [介绍一下 Redis 持久化机制](#介绍一下 Redis 持久化机制)
- [了解Redis管道技术吗](#了解Redis管道技术吗)
- [Redis集群](#Redis主从复制)
- 用过hyperLogLog

1. redis数据类型，说下跳跃表是如何实现的，可以用什么数据结构替换。
2. 删除过期key策略有哪些，内存淘汰策略有哪些，分别什么时候触发。
3. redis线程模型和内存模型。
4. redis集群方案。
5. 让你设计一个redis，你会怎么做，有看过redis源码吗。
6. 了解一致性hash算法吗，描述下。
7. 用redis实现一个分布式锁。
8. 缓存穿透、缓存击穿、缓存雪崩区别和解决方案。
9. [布隆过滤器知道吗，说下原理](布隆过滤器知道吗，说下原理)

#### 介绍一下 Redis 持久化机制

>  知识点 [Redis 持久化](../13-persistence/02-Redis/09-持久化/README.md) 

Redis 是基于内存实现的,所以断电以后数据会丢失,因此需要进行持久化,默认有两个持久化策略

- RDB , 快照, 全量备份, 恢复速度快 

  > RDB 模式下, redis 会 从fork 一个子进程,快照的持久化交给子进程来处理

- AOF , 日志, 增量备份,恢复速度慢

  > AOF 日志以文件形式存在的,当程序对 AOF 日志进行写操作时.实际上是将内容写到内核为文件描述符分配的一个内存缓冲中,然后内核会异步将脏数据刷到磁盘

##### COW机制要知道

> [01-COW-CopyOnWrite写时复制机制.md](../99-unclassified/01-COW-CopyOnWrite写时复制机制.md) 

##### 手动触发机制要知道

- 手动触发 RDB :  
  - bgsave(在后台异步(Asynchronously)保存当前数据库的数据到磁盘)
  - save (塞所有客户端，保存数据库)

- 手动触发 AOF

  - bgrewriteaof 根据现在数据库的数据重写 AOF 

  > [06-AOF持久化.md](../13-persistence/02-Redis/09-持久化/06-AOF持久化.md#AOF重写) 

#### 默认配置要知道

```
# 重写触发机制 
auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size 64mb
```

#### 了解Redis管道技术吗

> 知识点:  [17-管道.md](../13-persistence/02-Redis/03-Redis的基本数据结构/17-管道.md) 

Redis管道实际上是客户端技术,而不是服务端的技术,我们都知道,Redis 的非常快,但是性能瓶颈在于网络 IO, 客户端发送一个请求之后要阻塞等待服务器的返回,所以性能会有很大的浪费

管道技术实际上就是客户端一次发送多条命令,然后不逐条等待命令的返回,而是到最后一起读取返回结果,这样也就需要一次网络开销

##### 实现原理

客户端在使用管道发送多条命令时,服务器会将这些命令放到一个队列中

#### Redis主从复制

> 知识点: [01-主从复制.md](../13-persistence/02-Redis/04-Redis集群/01-主从复制.md) 

Redis集群有两种方式,一种是点对点的集群方式cluster 一种是master-salve 方式的主从复制

##### 两者的区别是  点对点的 cluster , 主从方式实际上是一种最终一致性的解决方案

主从复制,一个主多个从, 从也可以复制给其他从,复制实际上是异步同步的,当客户端修改了 Redis 主节点上的数据后,立即会返回,从节点会努力追赶主节点,最终从节点的状态会和主节点的状态一直

##### 优缺点

主从复制基于 RDB 的,在客户端连上后,会快照将数据传输,如果快照特别大,会非常耗时

主从如果主挂了,我们可以使用哨兵模式进行监控并组织 master 选举

 [02-哨兵.md](../13-persistence/02-Redis/04-Redis集群/02-哨兵.md) 



#### 布隆过滤器知道吗，说下原理

#### 用过hyperLogLog

> 知识点:   [09-hyperloglog.md](../13-persistence/02-Redis/03-Redis的基本数据结构/09-hyperloglog.md)   [09-01hyperloglog原理.md](../13-persistence/02-Redis/03-Redis的基本数据结构/09-01hyperloglog原理.md) 伯努利过程

HyperLogLog 是一数据结构,主要作用是 **一种有误差的去重计数方案**, 标准误差为 0.81%

Redis 的 HyperLogLog 通过牺牲准确率来减少内存空间的消耗，只需要12K内存，在标准误差0.81%的前提下，能够统计`2^64`个数据。所以 HyperLogLog 是否适合在比如统计日活月活此类的对精度要不不高的场景。



#### 为什么要使用 Redis

项目中的一些高频访问一般都是对数据的查询,如果全部直接查询数据库,当并发量大的时候,数据库压力会比较大,这个时候就需要使用缓存中间件来实现,目前主流的缓存中间件是 Redis 和 Memached , Redis 相比较 Memached 的缓存,支持的数据结构更多并且支持持久化,可能用这写数据结构实现很多场景

#### Redis 为什么快

> 我的电脑都可以达到 10 万的 **QPS（每秒内查询次数）**

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的，数据存在内存中，类似于**HashMap**，**HashMap**的优势就是查找和操作的时间复杂度都是O(1)；
- 数据结构简单，对数据操作也简单，**Redis**中的数据结构是专门进行设计的；
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 **CPU**，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
- 使用多路I/O复用模型，非阻塞IO；

#### 什么是上下文切换

 [QA.md](../../04-java/03-concurrency/QA.md#什么是上下文切换) 

 

#### Redis 有哪些数据结构

- 字符串 String 
- 字典 Hash , 类似于 Java 中的 HashMap ,应用场景例如购物车(key做商品 ID,value 用个数)
- 列表 List
- 集合 Set ,点赞等
- 有序集合 Zset ,热点数据排行榜
- 一种存在误差的去重计数器 HyperLogLog , 统计独立用户访问量
- 地址位置 GeoHash
- 发布订阅 Pub/Sub

- 布隆过滤器

#### 

#### 怎么使用 redis 分布式锁

使用 set 命令抢到锁,并且加上 nx 参数和 ex 参数,指定过期时间防止锁未释放

如果能设置成功证明获取了锁,如果设置失败证明竞争锁失败

#### 如何使用 Redis 做异步队列

一般直接使用 list 结构做队列结构做队列, rpush 生产消息, lpop 消费消息,当lpop没有消息的时候，要适当sleep一会再重试或者使用 blpop ,在没有消息的时候,阻塞等待消息到来

#### 什么是 pub/sub 模式 , 怎样可以一次发布,多次消费

使用 Pub/sub 模式 ,但是这个模式有一定的缺点,它不能持久化,如果在发布后,消费者宕机了,当消费者重启的时候,这条消息对于消费者来说是彻底丢失了, 5.0 以后,redis 使用 Stream 数据结构提供了一个可以持久化的消息机制

#### 如何使用 redis 实现延时队列

使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用**zrangebyscore**指令获取N秒之前的数据轮询进行处理。



#### 我们要找到固定key 开头的所有 key,怎么办

如果是开发可以直接用 keys命令,但是由于 redis 是单线程的,而且 keys 操作时间复杂度是 O(n),所以 keys 指令会阻塞服务一段时间

所以生产我们通常使用 scan ,scan 可以设置游标 ,但是返回结果有可能重复,

> 这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用**scan**指令，**scan**指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
>
> **不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。**

#### 什么是布隆过滤器

存在性检测

>  我们怎么知道请求的 key 在我们的数据库 里面是否存在，如果数据量特别大的话，我们怎么去快速判断。

#### 如何在海量元素中(例如 10 亿无序、不定长、不重复)快速判断一个元素是否存在?

布隆过滤器

## 持久化

#### Redis 是怎么持久化的?

Redis 有两种持久化机制,RDB 和 AOF 

RDB 快照镜像是做的全量持久化,备份的耗时比较长,宕机重启的时候可能会失去大量数据

AOF 做的是增量持久化,记录的是系统启动以来,所有的操作命令,它的缺点是恢复事件慢,默认的策略是 1s 刷一次脏页,所以系统宕机一般只会丢失 1s 的数据

一般生产两种持久化都会开启

#### 系统突然掉电怎么样

如果是开启了 AOF , 可以配置属性 sync ,默认是 1s 刷一次脏也, 当然我们可以实时刷,这样就不会丢失数据

#### rdb 原理

Redis 使用 Copy on Write (cow) 机制来实现快照持久化, Redis 在持久化的过程中会 fork 一个子线程,快照持久化完全按照子进程处理,父进程继续处理客户端

- 父进程在接受客户端请求时,使用操作系统的 cow 机制,复制原有的页数据,在复制的基础上更改
- 子进程会遍历原有的页数据数据结构,读取后序列化到磁盘中

**两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的。**

#### aof 原理

**RDB**五分钟一次生成快照，但是**AOF**是一秒一次去通过一个后台的线程`fsync`操作，那最多丢这一秒的数据。

**AOF**在对日志文件进行操作的时候是以`append-only`的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。

**AOF**的日志是通过一个叫**非常可读**的方式记录的，这样的特性就适合做**灾难性数据误删除**的紧急恢复了，比如公司的实习生通过**flushall**清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份**AOF**日志文件，把最后一条**flushall**命令删了就完事了。



#### Pipeline 有什么好处,为什么要用 pipline

可以将多次IO往返的时间缩减为一次，前提是**pipeline**执行的指令之间没有因果相关性。使用**redis-benchmark**进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是**pipeline**批次指令的数目。

## 主从复制

#### Redis同步机制是什么?主从机制是什么?

Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次**bgsave**，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

#### 是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？

**Redis Sentinal** 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

**Redis Cluster** 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

#### 哨兵作用

- 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。
- 消息通知：如果某个 **Redis** 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

#### 哨兵选举

#### 主从如何复制

你启动一台slave 的时候，他会发送一个**psync**命令给master ，如果是这个slave第一次连接到master，他会触发一个全量复制。master就会启动一个线程，生成**RDB**快照，还会把新的写请求都缓存在内存中，**RDB**文件生成后，master会将这个**RDB**发送给slave的，slave拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后master会把内存里面缓存的那些新命名都发给slave。

## 过期策略

**Redis**的过期策略，是有**定期删除+惰性删除**两种。

定期删除 :，默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。

惰性删除: 查询的时候才去判断是否过期,过期的话就删除

#### 内存淘汰机制

内存有上线的,满了以后会淘汰

- 拒绝所有写入命令,除了 del

- 淘汰最少使用的建
- 淘汰最少使用的过期的建
- 随机淘汰所有的建
- 随机淘汰过期的建
- 回收过期集合的建



## 应用

#### 什么是缓存雪崩

当大量的 key 在非常短的时间内同时失效,请求会直接打到数据库上,那么这个服务的数据库很有可能撑不住导致这个服务挂掉,我们一般会在设置 key 的时候加一个随机值或者直接允许的话不设置失效时间,有更新操作的时候再去更新缓存

#### 什么是缓存穿透

请求查询了一条不存在的数据,Redis 里也不存在,数据库里也不存在,这个时候会直接打在数据库上,比如我查主键为-1 的数据,很显然这个数据没有,持续的请求会导致数据库压力过大

- 缓存null 值
- 在接口层做一些校验,不合法的请求过滤掉
- 加布隆过滤器,判断请求的 key 在数据库里存不存在,不存在直接返回,存在的话才继续访问

#### 什么是缓存击穿

缓存击穿指的是当一个 key 非常热点的时候,不停的有请求过来,当这个 key 在失效的一瞬间,会有大量请求直接打到数据库,导致数据库压力,解决办法

- 设置热点的缓存永不过期

#### 雪崩,击穿,穿透

- 事前：**Redis** 高可用，主从+哨兵，**Redis cluster**，避免全盘崩溃。
- 事中：本地 **ehcache** 缓存 + **Hystrix** 限流+降级，避免**MySQL**被打死。
- 事后：**Redis** 持久化 **RDB**+**AOF**，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

#### 你了解最经典的KV、DB读写模式么？

最经典的缓存+数据库读写的模式，就是 **Cache Aside Pattern**

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

#### 什么是 Redis 的大 key

有时候Redis 使用不当,在 Redis 实例中形成了一个很大的对象,比如一个很大的 hash 或者很大的 set

这样的对象

#### 为什么是删除缓存，而不是更新缓存？

原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。

比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。

#### Redis 和 Memcached 有啥区别，为啥选择用Redis作为你们的缓存中间件

**Redis** 支持复杂的数据结构：

**Redis** 相比 **Memcached** 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作， **Redis** 会是不错的选择。

**Redis** 原生支持集群模式：

在 redis3.x 版本中，便能支持 **Cluster** 模式，而 **Memcached** 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

性能对比：

由于 **Redis** 只使用单核，而 **Memcached** 可以使用多核，所以平均每一个核上 **Redis** 在存储小数据时比 **Memcached** 性能更高。而在 100k 以上的数据中，**Memcached** 性能要高于 **Redis**，虽然 **Redis** 最近也在存储大数据的性能上进行优化，但是比起 **Remcached**，还是稍有逊色。

#### Redis 的线程模型了解么？

**Redis** 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 **Redis** 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 **Socket**，根据 **Socket** 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

- 多个 **Socket**
- IO 多路复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 **Socket** 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 **Socket**，会将 **Socket** 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

#### 缓存有哪些类型

缓存是高并发场景下提高热点数据访问性能的一个有效手段，在开发项目时会经常使用到。

缓存的类型分为：**本地缓存**、**分布式缓存**和**多级缓存**。

##### 本地缓存：

**本地缓存**就是在进程的内存中进行缓存，比如我们的 **JVM** 堆中，可以用 **LRUMap** 来实现，也可以使用 **Ehcache** 这样的工具来实现。

本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。

##### 分布式缓存：

**分布式缓存**可以很好得解决这个问题。

分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。

##### 多级缓存：

为了平衡这种情况，实际业务中一般采用**多级缓存**，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。

在目前的一线大厂中，这也是最常用的缓存方案，单考单一的缓存方案往往难以撑住很多高并发的场景。

#### Memcache

注意后面会把 **Memcache** 简称为 MC。

先来看看 MC 的特点：

- MC 处理请求时使用多线程异步 IO 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；
- MC 功能简单，使用内存存储数据；
- MC 的内存结构以及钙化问题我就不细说了，大家可以查看官网了解下；
- MC 对缓存的数据可以设置失效期，过期后的数据会被清除；
- 失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；
- 当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。

另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择**Redis**、**MongoDB**的重要原因：

- key 不能超过 250 个字节；
- value 不能超过 1M 字节；
- key 的最大失效时间是 30 天；
- 只支持 K-V 结构，不提供持久化和主从同步功能。



0、在集群模式下，Redis 的 Key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 Hash 算法吗？

1、使用Redis有哪些好处？

2、Redis相比Memcached有哪些优势？

3、Redis常见性能问题和解决方案

4、MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？

5、Memcache与Redis的区别都有哪些？

6、Redis 常见的性能问题都有哪些？如何解决？

7、在什么样的场景下可以充分的利用Redis的特性，大大提高Redis的效率？

8、Redis的缓存雪崩、穿透、击穿了解么？有什么异同点？分别怎么解决？

9、Redis的基本类型有哪些？他们的使用场景了解么？比较高级的用法你使用过么？

10、Redis主从怎么同步数据的？集群的高可用怎么保证？持久化机制了解么？

11、为什么 redis 单线程却能支撑高并发？

12、如何保证缓存和数据库数据的一致性？

13、项目中是怎么用缓存的，用了缓存之后会带来什么问题？

#### 加分项

如果想要在面试中获得更好的表现，还应了解下面这些加分项。

- 是要结合实际应用场景来介绍缓存的使用。例如调用后端服务接口获取信息时，可以使用本地+远程的多级缓存；对于动态排行榜类的场景可以考虑通过 **Redis** 的 **Sorted set** 来实现等等。
- 最好你有过分布式缓存设计和使用经验，例如项目中在什么场景使用过 **Redis**，使用了什么数据结构，解决哪类的问题；使用 MC 时根据预估值大小调整 **McSlab** 分配参数等等。
- 最好可以了解缓存使用中可能产生的问题。比如 **Redis** 是单线程处理请求，应尽量避免耗时较高的单个请求任务，防止相互影响；**Redis** 服务应避免和其他 CPU 密集型的进程部署在同一机器；或者禁用 Swap 内存交换，防止 **Redis** 的缓存数据交换到硬盘上，影响性能。再比如前面提到的 MC 钙化问题等等。
- 要了解 **Redis** 的典型应用场景，例如，使用 **Redis** 来实现分布式锁；使用 **Bitmap** 来实现 **BloomFilter**，使用 **HyperLogLog** 来进行 UV 统计等等。
- 知道 Redis4.0、5.0 中的新特性，例如支持多播的可持久化消息队列 Stream；通过 Module 系统来进行定制功能扩展等等。

