# JVM

- 垃圾收集有哪几种,分别在什么时候
- 如何选择垃圾收集器

- [JVM运行时数据区域和内存模型描述，jdk8为什么移除永久代](#JVM运行时数据区域和内存模型描述，jdk8为什么移除永久代)

- [描述下JVM类加载过程，如何自定义类加载器](#描述下JVM类加载过程，如何自定义类加载器)

- [新生代和老年代分别用的什么垃圾回收器](#新生代和老年代分别用的什么垃圾回收器)

> 新生代和老年代什么时候会触发GC。
>
> 1. 四种引用区别。
> 2. CMS垃圾回收过程描述，CMS有哪些缺点，对比G1。
> 3. GC调优步骤，有实操过吗。
> 4. 描述下JVM类加载过程，如何自定义类加载器。
> 5. 
> 6. 泛型是如何实现的，逃逸分析知道吗，说下。
> 7. OOM、内存泄漏如何排查，用到哪些工具，如果不用工具如何进行定位。
> 8. 机器负载变高如何排查，如果发现是jvm进程引起的，如何定位到代码行。

#### JVM运行时数据区域和内存模型描述，jdk8为什么移除永久代

> 知识点:  [运行时数据区域](../07-jvm/02-Java 内存区域与内存溢出异常/README.md) 

把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存）。这样做有什么好处？

对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。

而且我们现在用到的字节码增强工具,比如 代理技术 asm 技术等动态运行时生成字节码,这使得方法区很容易出现溢出问题,因此会用元空间替代永久代

#### 新生代和老年代分别用的什么垃圾回收器

> 知识点

<img src="../assets/image-20200526224033515.png" alt="image-20200526224033515" style="zoom: 67%;" />

#### 描述下JVM类加载过程，如何自定义类加载器

> 知识点:  [类加载的时机](../07-jvm/07-虚拟机类加载机制/01-类加载的时机.md) 

#### 不同的类加载器加载相同的 class 文件instanceof

> 知识点:  [类加载器](../07-jvm/07-虚拟机类加载机制/02-类加载器.md) 

不同的类加载器加载同一个 class 文件一定不同, instanceof 也是 false

#### 描述下jvm模型，为什么需要双亲委派模型。

> 知识点: 双亲委派机制