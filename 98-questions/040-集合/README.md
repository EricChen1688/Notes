# 集合

#### 说一下HashMap

#### HashMap为什么线程不安全



hashmap底层原理，为什么线程不安全，扩容的具体思路，有没有线程安全的map
19.讲一下currenthashmap的原理，1.7和1.8区别，扩容，协助扩容

# Java

1. 为什么String定义为final。
2. 描述下java集合，项目中用到哪些。
3. StringBuilder和StringBuffer的区别。

## Collection







### HashMap

>  [051-hashMap的底层原理.md](../04-java/02-collections/03-map/051-hashMap的底层原理.md) 

> HashMap 是我们经常使用的集合类
>
> - 是数组和链表的组合, 1.7 叫 Entry, 1.8叫Node
> - 根据 key 的值计算 Hash 插入 Node, 1.7是头插法,1.8 是尾插法
> - 扩容机制,负载因子 0.75f, 

##### HashMap的扩容机制

- 根据原来的容量 Node *2 
- 将原来的参数 rehash

插入的的时候多个线程容易出现环形链表,所以1.8 采用尾插法

##### 为什么线程不安全

get 和 put 没有加同步锁. 上一秒 put,下一秒不能保证拿到的是更新的值

##### 初始长度

16 , 2^4 , 建议 2的幂, 因为方便位运算,计算 key的时候使用到额是位运算,能够提高性能

##### HashMap中常用的方法有哪些，什么时候会触发树化，jdk1.7和1.8实现的差异，1.7的实现为什么会出现死锁，画图说明下。HashMap和TreeMap的区别。

## 















## 多线程

### 轻量级锁加解锁过程详解

> https://zhuanlan.zhihu.com/p/141554048

从Java SE 1.6开始，为了减少获得锁和释放锁带来的性能消耗，就引入了轻量级锁。轻量级锁在对象内存布局中 MarkWord 锁标志位为 00，它可以由偏向锁对象因存在多个线程访问而升级成轻量级锁，当然，轻量级锁也可能因多个线程同时访问同步代码块升级成重量级锁。

 [02-synchronized的实现原理与应用.md](../04-java/03-concurrency/04-Java并发机制的底层实现原理/02-synchronized的实现原理与应用.md) 







1. 说下枚举类型，底层实现原理，项目中是如何使用的。
2. 详细描述Error和Exception(运行期和编译期)的区别。
3. 创建线程的方式，线程的生命周期。
4. ThrealLocal实现原理，为什么会出现内存泄漏。
5. volatile关键字原理，项目中是如何使用的。
6. synchronized和lock的区别，底层实现原理。AQS队列实现原理，用了哪些设计模式。公平锁和非公平锁、独占锁和共享锁、读写锁分别是如何实现的，为什么说非公平锁比公平锁性能高。
7. 序列化和反序列化。
8. 深拷贝和浅拷贝区别。
9. java内部类的区别(成员*内部类*、静态嵌套类、方法*内部类*、匿名*内部类* )。
10. java线程池参数描述，线程池工作原理，线程池如何调优。
11. 主线程到达一个条件，需要多个子线程去执行任务，等子任务都执行完后再往下走，如何编写代码(CountDownLatch)。
12. 写个程序，两个线程交叉打印1到100的数字，需要多种实现方式。



































