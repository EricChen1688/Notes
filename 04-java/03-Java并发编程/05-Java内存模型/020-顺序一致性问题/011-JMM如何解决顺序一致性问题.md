# 011-JMM如何解决顺序一致性问题

[TOC]

## JMM如何解决顺序一致性问题

 [010-可见性、原子性和有序性问题：并发编程Bug的源头.md](../../01-tutorials/010-并发理论基础-1/010-可见性、原子性和有序性问题：并发编程Bug的源头.md) 

所谓的重排序其实就是指执行的指令顺序。编译器的重排序指的是程序编写的指令在编译之后，指令可能会产生重排序来优化程序的执行性能。从源代码到最终执行的指令，可能会经过三种重排序。

### 1.解决重排序问题

为了提高程序的执行性能，编译器和处理器都会对指令做重排序，其中处理器的重排序在前面已经分析过了。

当然并不是所有的程序都会出现重排序问题 编译器的重排序和 CPU 的重排序的原则一样，会遵守数据 依赖性原则，编译器和处理器不会改变存在数据依赖关系 的两个操作的执行顺序,比如下面的代码，

```java
a=1;b=a;
a=1;a=2;
a=b;b=1;
```

这三种情况在单线程里面如果改变代码的执行顺序，都会 导致结果不一致，所以重排序不会对这类的指令做优化。 这种规则也成为 as-if-serial。不管怎么重排序，对于单个 线程来说执行结果不能改变。比如

```java
int a=2; //1
int b=3; //2
int rs=a*b; //3
```

1x和 3、2 和 3 存在数据依赖，所以在最终执行的指令中， 3 不能重排序到 1 和 2 之前，否则程序会报错。由于 1 和 2 不存在数据依赖，所以可以重新排列 1 和 2 的顺序

### 2.JMM 层面的内存屏障

为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障来禁止特定类型的处理器的重排序， 在 JMM 中把内存屏障分为四类

| 屏障类型           | 指令示意                     | 备注                                                         |
| ------------------ | ---------------------------- | ------------------------------------------------------------ |
| LoadLoadBarriers   | load1;LoadLoad;Load2         | 确保 load1数据的装载优先于 load2 以及所有后续装载指令的装载  |
| StoreStoreBarriers | Store1;storestore;store2     | 确保 store1数据对其他处理器可见优先于 store2 以及所有后续存储指令的存储 |
| LoadStoreBarriers  | `load1`;`loadstore`;`store2` | 确保`load1`数据装载优先于 `store2`以及后续的存储指令刷新到内存 |
| StoreLoadBarriers  | `store1`;`storeload`;`load2` | 确保 store1 数据对其他处理器变得可见,优先于 load2 以及所有后续装载指令的装载;这条内存屏障指令是一个全能型的屏障 |

## 四种内存屏障详解

Java的内存屏障通常所谓的四种即`LoadLoad`,`StoreStore`,`LoadStore`,`StoreLoad`实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。

#### 1.LoadLoad屏障

对于这样的语句

```
Load1; 
LoadLoad; 
Load2，
```

在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。

#### 2.StoreStore屏障

对于这样的语句

```
Store1; 
StoreStore; 
Store2
```

在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。

#### 3.LoadStore屏障

```
Load1; 
LoadStore; 
Store2
```

对于这样的语句，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。

#### 4.StoreLoad屏障

对于这样的语句

```
Store1; 
StoreLoad; 
Load2
```

在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。

**它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能**

