# 020-自旋锁

[TOC]

## 什么是自旋锁

自旋锁认为,如果持有锁的线程能够在很短的事件内释放锁资源,那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞,挂起状态, 只需要等一等(自旋) , 在等待持有锁的线程释放锁之后即可获取锁,这样就避免了用户线程内核态状态上的切换导致锁时间消耗

## 长期自旋占用CPU

线程在自旋的过程中会占用 CPU,如果长时间获取不到锁,会产生 CPU 的浪费,甚至有时线程永远无法获取锁而导致 CPU 永远占用,

所以要设置一个自旋等待时间, 超时则退出自旋模式并释放持有的锁

## 自旋锁的优缺点

#### 优点

- 减少 CPU上下文切换,对于占用锁的事件非常短或者锁竞争不激烈的代码块来说性能大幅度提升,因为自旋的 CPU 耗时明显少于线程阻塞,挂起,再唤醒时两次 CPU上下文切换所用的时间

#### 缺点

- 在持有锁的线程中锁时间过长或者锁的竞争过于激烈时,线程在自旋过程中会长时间内获取不到资源,引起 CPU浪费

## 自旋锁的时间阈值

JDK不同版本锁采用的自旋周期不同

- JDK1.5 为固定时间
- JDK1.6 引入了自适应自旋锁 

## 什么是自适应自旋锁

JDK1.6之后, 虚拟机堆循环次数进行了优化的机制

- 如果之前成功获取过锁, 你续集就会以为这次自旋也很有可能成功, 那么自旋循环等待时间更长
- 如果很少成功获取锁, 那么在获取这个锁时, 直接省略自旋过程, 以避免消耗处理器资源

不再设置阈值,而是由上一次同一个锁上锁的自旋时间以及锁的拥有者状态来决定的,可以基本认为一个线程上下文切换的事件就是一个最佳时间

## 时间局部性原则和空间局部性原则

 [101-局部性原理.md](../05-Java内存模型/101-局部性原理.md) 