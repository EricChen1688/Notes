## 001-IO读写的基本原理.md

[TOC]

用户进程对于IO的读写, 依赖于底层IO读写,基本上会用到底层的read& write量大系统调用, 在不同的操作系统中, IO读写的系统通用的名称可能不完全一样,但是基本功能是一样的

## read%write指令

read系统调用, 并不是直接从设备把数据读取到内存中, write 调用也不是简单地把数据写入到物理设备

上层无论是调用操作系统的read, 还是调用操作系统的write, 都会涉及到缓冲区

- read系统调用, 是把数据从内核缓冲区复制到进程缓冲区
- write系统调用, 是把数据从进程缓冲区复制到内核缓冲区

所以, 上层程序的IO操作, 实际上不是物理设备级别的读写, 而是缓存的复制, read&write 两大系统的调用, 都不负责数据在内核缓冲区和物理设备(如磁盘)之间的交换, 这项底层的读写交换, 是由操作系统内核(Kernal) 来完成的

## 为什么要有内核缓冲区和进程缓冲区

缓冲区的作用是为了 **减少频繁地与设备之间进行物理交换**

- 外部设备的读写,涉及到操作系统的中断
- 发生系统中断时, 需要保存之前的进程数据和状态等信息, 而中断结束以后,还需要恢复之间的进程数据和状态等信息

为了减少底层系统的时间损耗,性能损耗,于是出现了内存缓冲区

#### 有了内存缓冲区的优势

有了内存缓冲区

- 上层应用使用read系统调用时, 仅仅把数据从内核缓冲区复制到上层应用的缓冲区(进程缓冲区中)

- 上层应用使用write系统调用时, 仅仅把数据从进程缓冲区复制到内核缓冲区中

底层操作会对内核缓冲区进行监控,等待缓冲区达到一定的数量的时候,再进行IO设备的中断处理,集中执行物理设备的实际IO, 这种机制提升了系统的性能,至于什么时候中断(读中断, 写中断) , 由操作系统内核决定