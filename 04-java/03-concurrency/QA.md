# QA

#### 什么是上下文切换

我们都知道 CPU 通过给每个线程分配 CPU 的时间片来显示多线程的,这个时间片通常非常短,所以 CPU 会不停地切换线程来执行,让我们感觉好像在同时执行,在切换前,会保存上一个任务的状态,一遍下次切回到这个任务,那么这任务从保存到再加载的过程就是一次上下文切换

#### 多线程程序一定比单线程程序块吗?

不一定,因为线程有创建和上下文切换的开销

#### 如何减少上下文切换

- 无锁并发编程, 因为多线程竞争锁的时候,会引起上下文切换,所以我们要避免使用锁

比如我们可以把数据根据 ID 按照 Hash 算法取模分段,不同的线程处理不同段的数据

- CAS 算法 , compare and set 使用自旋的方式进行 cas,可以避免锁竞争

比如我们可以用 Atomic 包下面的工具类

- 使用最少线程.避免创建不需要的线程,尽量使用线程池复用
- 协程: 在单线程里实现多任务的调度,并在单个线程里维持多个任务间的切换

#### 减少线程切换

使用 jstack 命令查看,查看waiting 状态的线程数量,定位是哪里的线程大量在空闲

#### 什么是死锁

两个线程互相等待对方释放锁才能继续运行的情况

开发中可能会遇到,比如线程 1 拿到了锁之后,因为一些异常没有释放锁,死循环了等等

#### 避免死锁的常见方法

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源,尽量保证每个锁值占用一个资源
- 尝试使用定时锁, lock.tryLock(timeout)
- 对于数据库锁,加锁和解锁必须在一个数据库连接里,否则会出现解锁失败的情况

#### 什么是 volatile 关键字,有什么作用

volatile 关键字确保了共享变量在多线程下的可见性,它相对于 synchronzined 关键字,成本更低,不会引起线程上下文的切换

#### voliatile 是如何保证内存可见性

volatile 关键字编译后是使用 lock 指令修饰变量的.主要做了两件事:

- 强制刷新处理器的缓存到内存
- 使其他 CPU里缓存的数据失效

从而实现了内存的可见性

#### synchronzied 的实现原理与应用

- 对于普通方法,锁的是当前实例对象
- 对于静态同步方法,锁的是当前类的 Class 对象
- 对于同步方法块,没锁的是 sychronzied 括号里的对象 , 通过 monitorenter 和 monitorexist 指令实现

synchronzied 锁是存在在 java 对象头里的,主要标识了四种状态

- 无锁状态
- 偏向锁状态
- 轻量级锁状态
- 重量级锁状态

会随着竞争情况逐渐升级,但是只会升级不会降级

#### 什么是偏向锁(不会自旋)

大多数情况下,锁一般不存在竞争,往往都是一个线程获取锁,所以引入了偏向锁

偏向锁的ID存储在对象头的 markword 中

线程 1 访问同步块的时候,会先检查 markword 里有没有信息,没有信息会使用 CAS 替换掉markword 里的信息

如果替换成功,就说明获取到了这个锁

那么什么时候释放呢,偏向锁实际上使用的是一种出现竞争才释放锁的机制

这个时候,线程 2 访问了代码块,它也一样先检查 markword 里的信息并 CAS 替换,这个时候就出现了锁竞争,会走锁撤销逻辑

锁撤销实际上线程1 会被暂停,并检查它是否活跃, 不活跃然后将 markword 里的线程 ID 设置为空然后再恢复线程

如果锁撤销成功,那么线程 2 就可以通过 CAS 获取锁

如果锁撤销不成功,那么存在锁竞争锁就会膨胀成轻量级锁,实际上就是线程 2 通过自旋获取锁

#### 轻量级锁(自旋)

如果成功使用CAS将对象头重的Mark Word替换为指向锁记录的指针，则获得锁，失败则当前线程尝试使用自旋(循环等待)来获取锁。

轻量级锁的解锁：

> 当有另一个线程与该线程同时竞争时，锁会升级为重量级锁。为了防止继续自旋，一旦升级，将无法降级。

#### 重量级锁

重量级锁直接让线程阻塞,相应时间缓慢