# QA

#### 多线程程序一定比单线程程序块吗?

不一定,因为线程有创建和上下文切换的开销

#### 如何减少上下文切换

- 无锁并发编程, 因为多线程竞争锁的时候,会引起上下文切换,所以我们要避免使用锁

比如我们可以把数据根据 ID 按照 Hash 算法取模分段,不同的线程处理不同段的数据

- CAS 算法 , compare and set 使用自旋的方式进行 cas,可以避免锁竞争

比如我们可以用 Atomic 包下面的工具类

- 使用最少线程.避免创建不需要的线程,尽量使用线程池复用
- 协程: 在单线程里实现多任务的调度,并在单个线程里维持多个任务间的切换

#### 减少线程切换

使用 jstack 命令查看,查看waiting 状态的线程数量,定位是哪里的线程大量在空闲

#### 什么是死锁

两个线程互相等待对方释放锁才能继续运行的情况

开发中可能会遇到,比如线程 1 拿到了锁之后,因为一些异常没有释放锁,死循环了等等

#### 避免死锁的常见方法

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源,尽量保证每个锁值占用一个资源
- 尝试使用定时锁, lock.tryLock(timeout)
- 对于数据库锁,加锁和解锁必须在一个数据库连接里,否则会出现解锁失败的情况

#### 什么是 volatile 关键字,有什么作用

volatile 关键字确保了共享变量在多线程下的可见性,它相对于 synchronzined 关键字,成本更低,不会引起线程上下文的切换

#### voliatile 是如何保证内存可见性

volatile 关键字编译后是使用 lock 指令修饰变量的.主要做了两件事:

- 强制刷新处理器的缓存到内存
- 使其他 CPU里缓存的数据失效

从而实现了内存的可见性

#### synchronzied 的实现原理与应用

- 对于普通方法,锁的是当前实例对象
- 对于静态同步方法,锁的是当前类的 Class 对象
- 对于同步方法块,没锁的是 sychronzied 括号里的对象 , 通过 monitorenter 和 monitorexist 指令实现

synchronzied 锁是存在在 java 对象头里的,主要标识了四种状态

- 无锁状态
- 偏向锁状态
- 轻量级锁状态
- 重量级锁状态

会随着竞争情况逐渐升级,但是只会升级不会降级

#### 什么是偏向锁

大多数情况下,锁一般不存在竞争,往往都是一个线程获取锁,所以引入了偏向锁

当一个线程访问同步块并获取锁的时候,会在对象头和栈帧中的锁记录里存储偏向锁的线程 ID,以后如果还是这个线程再次进入或退出的时候没救不需要再进行 CAS 加锁或者解锁,只简单测试一下对象头的 markword 里面是否有指向当前线程的偏向锁,如果不是,就进行锁撤销操作,从而当前线程获得锁

#### 什么是偏向锁的锁撤销

- 如果有,那么标识当前线程已经获取了锁,直接执行就行了
- 如果没有,就使用 CAS 竞争,这个时候原来拥有偏向锁的线程会被暂停,检查是否活跃,如果不活跃,
  - 就把对象头设置为无锁状态
  - 如果线程仍然或者

#### 轻量级锁

如果线程存在竞争,就会从偏向锁升级成为轻量级锁,通常是使用自旋来获取锁,如果成功,表示没有竞争,如果失败,就会膨胀成重量级锁

#### 重量级锁

重量级锁直接让线程阻塞,相应时间缓慢