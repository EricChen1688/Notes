 [01-introduction.md](../01-tutorial/01-introduction.md) 

#线程简介

##什么是线程

现代操作系统调度最小单元是线程。

一个Java程序从`main()`方法开始执行，看似只有一个线程，其实有包含多个线程。

```java
import java.lang.management.*;

public class HelloWorld {
    public static void main(String []args) {
		//获取Java线程管理MXBean
      ThreadMXBean threadMXBean  = ManagementFactory.getThreadMXBean();
		//不需要获取同步的monitor 和 synchronizer信息，仅获取线程和线程堆栈信息
	  ThreadInfo[] infos = threadMXBean.dumpAllThreads(false,false);
		//遍历线程信息，仅打印线程ID和线程名称
	  for(ThreadInfo info : infos){
	  	System.out.println("[" + info.getThreadId() + "]" + info.getThreadName());
	  }
    }
}
```

输出：

```java
[4]Signal Dispatcher	//分发处理发送给JVM信号的线程
[3]Finalizer					//调用对象finalize方法的线程
[2]Reference Handler	//清楚Reference的线程
[1]main								//main线程、用户程序入口
```

可以看出，一个Java程序的运行不仅仅是main()方法的运行，而是main线程和多个其他线程共同运行。

### 为什么要使用多线程

- 更多的处理器核心

线程是大多数操作系统调度的基本单元,一个程序做为一个进程来运行,程序运行过程中能够创建多个

- 更快的响应时间

和消息队列的原理一样,减少响应时间

- 更好的编程模型

Java 为多线程编程提供了良好,考究并且一直的编程模型

## 线程的优先级

现代操作系统基本采用时分的形式调度运行的线程,操作系统会分出一个个时间片,线程会被分配到若干个时间片,当线程的时间片用完了就会发生线程调度,并等待着下次分配

- 线程是分配到的时间片也就决定了线程使用处理器的资源的多少
- 线程的优先级决定线程需要多或者少分诶一些处理器资源的线程属性

```java
public class Priority {
    private static volatile boolean notStart = true;
    private static volatile boolean notEnd = true;

    public static void main(String[] args) throws Exception {
        List<Job> jobs = new ArrayList<Job>();
        for (int i = 0; i < 10; i++) {
            int priority = i < 5 ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;
            Job job = new Job(priority);
            jobs.add(job);
            Thread thread = new Thread(job, "Thread:" + i);
            thread.setPriority(priority);
            thread.start();
        }
        notStart = false;
        Thread.currentThread().setPriority(8);
        System.out.println("done.");
        TimeUnit.SECONDS.sleep(10);
        notEnd = false;

        for (Job job : jobs) {
            System.out.println("Job Priority : " + job.priority + ", Count : " + job.jobCount);
        }

    }

    static class Job implements Runnable {
        private int priority;
        private long jobCount;

        public Job(int priority) {
            this.priority = priority;
        }

        @Override
        public void run() {
            while (notStart) {
                Thread.yield();
            }
            while (notEnd) {
                Thread.yield();
                jobCount++;
            }
        }
    }
}
```

输出

```java
done.
Job Priority : 1, Count : 1701573
Job Priority : 1, Count : 1701946
Job Priority : 1, Count : 1701555
Job Priority : 1, Count : 1701512
Job Priority : 1, Count : 1701405
Job Priority : 10, Count : 1701827
Job Priority : 10, Count : 1701131
Job Priority : 10, Count : 1701649
Job Priority : 10, Count : 1701017
Job Priority : 10, Count : 1701665
```

可以看出线程的优先级没有生效,优先级 1 和优先级 10 的 Job 计数的结果非常相近,没有明显差距,

**程序的正确性不能依赖线程的优先级高低**

## Daemon 线程

Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。
**当一个Java虚拟机不存在非Daemon**线程时，Java虚拟机将会退出，可以通过Thread.setDaemon(true)将线程设置为Daemon线程。

Daemin线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon 线程中的finally块并不一定会执行：

```java
public class Daemon {
    public static void main(String[] args) {
        Thread thread = new Thread(new DaemonRunner());
        thread.setDaemon(true);
        thread.start();
    }
    static class DaemonRunner implements Runnable {
        @Override
        public void run() {
            try {
                SleepUtils.second(100);
            } finally {
                System.out.println("DaemonThread finally run.");
            }
        }
    }
}
```




不会输出DaemonThread ...,因为main线程（非Daemon线程）在启动了线程DaemonRunner之后随着main方法执行完毕而终止，而此时Java虚拟机已经没有非Daemon线程，虚拟机需要退出，Java虚拟机中的所有Daemon线程都需要立刻终止，因此DaemonRunner立即终止，但是DaemonRunner中的finally块并没有执行。

所以：

**在构建Daemon线程时，不能依靠`finally`块中的内容确保执行关闭或者清理资源的逻辑**`