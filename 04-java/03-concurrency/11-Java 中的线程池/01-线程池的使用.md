# 线程池的使用

只需要直接使用 Executors 的工厂方法，就可以使用线程池:

- `newFixedThreadPool`:该方法返回一个固定数量的线程池，线程数不变，当有一个任务提交 时，若线程池中空闲，则立即执行，若没有，则会被暂缓在一个任务队列中，等待有空闲的 线程去执行。
- `newSingleThreadExecutor`: 创建一个线程的线程池，若空闲则执行，若没有空闲线程则暂缓 在任务队列中。 
- `newCachedThreadPool`:返回一个可根据实际情况调整线程个数的线程池，不限制最大线程 数量，若用空闲的线程则执行任务，若无任务则不创建线程。并且每一个空闲线程会在 60 秒 后自动回收
- `newScheduledThreadPool`: 创建一个可以指定线程的数量的线程池，但是这个线程池还带有 延迟和周期性执行任务的功能，类似定时器。

```java
/**
 * <p>
 * 简单的线程池使用
 * </p>
 *
 * @author EricChen 2020/04/05 22:24
 */
public class ThreadPoolTest implements Runnable {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for(int i = 0; i < 100; i++) {
            executorService.execute(new ThreadPoolTest());
        }
        executorService.shutdown();
    }

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("ThreadName:" + Thread.currentThread().getName());
    }
}
```

## ThreadPoolExecutor

ThreadpoolExecutor 有多个重载的构造方法，我们可以基于它最完整的构造方法来分析 先来解释一下每个参数的作用

```java
public ThreadPoolExecutor(int corePoolSize, //核心线程数量
    int maximumPoolSize, //最大线程数
    long keepAliveTime, //超时时间,超出核心线程数量以外的线程空余存活时间
    TimeUnit unit, //存活时间单位
    BlockingQueue<Runnable> workQueue, //保存执行任务的队列 
    ThreadFactory threadFactory,//创建新线程使用的工厂 
    RejectedExecutionHandler handler //当任务无法执行的时候的处理方式s
)
```

线程池初始化时是没有创建线程的，线程池里的线程的初始化与其他线程一样，但是在完成任务以后，该线程不会自行销毁，而是以挂起的状态返回到线程池。直到应用程序再次向线程池发出请求时，线程池里挂起的线程就会再度激活执行任务。这样既节省了建立线程所造成的性能损耗，也可以让多个任务反复重用同一线程，从而在应用程序生存期内节约大量开销

### newFixedThreadPool

用途: FixedThreadPool 用于负载比较大的服务器，为了资源的合理利用，需要限制当前线程数量

```java
public static ExecutorService newFixedThreadPool(int nThreads) { 
return new ThreadPoolExecutor(
  nThreads, 
  nThreads,
	0L, 
  TimeUnit.MILLISECONDS,
	new LinkedBlockingQueue<Runnable>());//使用的是链表阻塞队列
}
```

FixedThreadPool 的核心线程数和最大线程数都是指定值，也就是说当线程池中的线程数超 过核心线程数后，任务都会被放到阻塞队列中。另外 `keepAliveTime`为 0，也就是超出核心 线程数量以外的线程空余存活时间

而这里选用的阻塞队列是` LinkedBlockingQueue`，使用的是默认容量 `Integer.MAX_VALUE`， 相当于没有上限

这个线程池执行任务的流程如下:

1. 线程数少于核心线程数，也就是设置的线程数时，新建线程执行任务
2. 线程数等于核心线程数后，将任务加入阻塞队列
3. 由于队列容量非常大，可以一直添加
4. 执行完任务的线程反复去队列中取任务执行

### newCachedThreadPool

> 使用SynchronousQueue的目的就是保证“对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务

CachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程; 并且没有核心线程，非核心线程数无上限，但是每个空闲 的时间只有 60 秒，超过后就会被回收。

```java
public static ExecutorService newCachedThreadPool() { 
  return new ThreadPoolExecutor(
  0, 
  Integer.MAX_VALUE,
	60L,
  TimeUnit.SECONDS,
  new SynchronousQueue<Runnable>());
}
```

这个线程池执行任务的流程如下:

1. 没有核心线程，直接向 `SynchronousQueue` 中提交任务
2. 如果有空闲线程，就去取出任务执行;如果没有空闲线程，就新建一个
3. 执行完任务的线程有 60 秒生存时间，如果在这个时间内可以接到新任务，就可以继续活下去，否则就被回收

### newSingleThreadExecutor

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定 顺序(FIFO, LIFO, 优先级)执行