# 重排序

## 一句话定义

重排序是指编译器和处理器为了优化程序性能从而对指令序列进行重新排序的一种手段

## 分类

在执行程序时,为了提高性能, 编译器和持利器常常会对指令进行重排序,分三种类型:

- 编译器优化的重排序

- 指令级并行的重排序

- 内存系统的重排序

#### 编译器优化的重排序

编译器在不改变单线程程序语义的前提下,可以重新安排语句的执行顺序

编译器的重排序，JMM 提供了禁止特定类型的编译器重排序,处理器重排序，JMM 会要求编译器生成指令时，会插入内存屏障来禁止处理器重排序

#### 指令级并行的重排序

现代处理器采用了指令级并行技术(Instruction-Level Parallelism, ILP) 来讲多条指令重叠执行,**如果不存在数据依赖性,处理器可以改变语句对应机器指令的执行顺序**

#### 内存系统的重排序

由于处理器使用缓存和读/写缓存区,这使得加载和存储操作看上去可能是在乱序执行

#### 重排序的顺序

![image-20200228173813918](../../../assets/image-20200228173813918.png)

2 和 3 属于处理器重排序。这些重排序可能会导致可见性问题。

## 数据依赖性

如果两个操作访问的同一个变量,且这两个操作中有一个为写操作,此时这两个操作之间就存在数据依赖性

| 名称   | 代码实例 | 说明                        |
| ------ | -------- | --------------------------- |
| 写后读 | a=1;b=a; | 写一个变量之后,再读这个位置 |
| 写后写 | a=1;a=2; | 写一个变量之后,再写这个变量 |
| 读后写 | a=b;b=1; | 读一个变量之后,再写这个变量 |

只要重排序这两个操作的执行熟悉怒,程序的执行结果就会改变

所以,为了维护数据依赖性,编译器和处理器在进行重排序的时候不会改变存在依赖关系的两个操作的执行顺序

## as-if-serial 语义

as-if-serial 语义: 不管你怎么重排序(编译器和处理器为了提高并行读),单线程程序的执行结果都不会被改变

**编译器,runtime 和处理器都必须遵循这个语义**

#### 简单的示例

```java
double pi = 3.14;        //A
double r = 1.0 ;         //B
double area = pi * r * r;//C
```



<img src="../../../assets/image-20200306123504728.png" alt="image-20200306123504728" style="zoom:50%;" />

- A 和 C 之间存在数据依赖关系
- B 和 C 之间存在数据依赖关系
- C不能排到 A和 B 的前面,程序的结果将会被改变
- A 和 B 可以重排序

<img src="../../../assets/image-20200306123723840.png" alt="image-20200306123723840" style="zoom:50%;" />

as-if-serial 规则使得单线程程序员无需担心重排序会干扰他们,也无需担心内存可见性问题



## 内存屏障

为了保证内存可见性,Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序

<img src="../../../assets/image-20200229010134877.png" alt="image-20200229010134877" style="zoom:50%;" />

值得注意的是`StroreStore Barriers`是一个全能型的屏障,它同事具有其他 3 个屏障的效果,执行这个屏障的开销也很昂贵,因为当前处理器通常吧写缓冲区中的数据全部刷新到内存中取