# 双重检查锁定和延迟初始化

双检锁是单例常用的模式,但是如下写法会有问题

```java
public class DoubleCheckedLocking { //1
    private static Instance instance; //2

    public static Instance getInstance() { //3
        if (instance == null) { //4:第一次检查
            synchronized (DoubleCheckedLocking.class) { //5:加锁
                if (instance == null) //6:第二次检查
                    instance = new Instance(); //7:问题的根源出在这里
            } //8
        } //9
        return instance; //10
    } //11

    static class Instance {
    }
}

```

原因是重排序的问题

#### 安全的使用方式

![image-20200306175413539](assets/image-20200306175413539.png)

方案的本质是通过禁止 2 和 3 的重排序,确保线程安全

```java
public class DoubleCheckedLocking { //1
    private volatile static Instance instance; //2

    public static Instance getInstance() { //3
        if (instance == null) { //4:第一次检查
            synchronized (DoubleCheckedLocking.class) { //5:加锁
                if (instance == null) //6:第二次检查
                    instance = new Instance(); //7:问题的根源出在这里
            } //8
        } //9
        return instance; //10
    } //11

    static class Instance {
    }
}


```

## 基于类初始化的解决方案

JVM在类的初始化阶段,即在 Class 被加载后,且被线程使用之前,会执行类的初始化,在执行类的初始化之前,JVM 会去获取一个锁,这个锁可以同步多个线程对同一个类的初始化

基于这个特性:

![image-20200618075810561](../../../assets/image-20200618075810561.png)

 

```java
public class InstanceFactory {
    private static class InstanceHolder {
        public static Instance instance = new Instance();
    }

    public static Instance getInstance() {
        return InstanceHolder.instance; //这里将导致InstanceHolder类被初始化
    }

    static class Instance {
    }
}

```

 [04-singleton-pattern.md](../../../01-design-patterns/02-creational-patterns/04-singleton-pattern.md) 

允许初始化对象(步骤2)和设置 intance 指向内存空间(步骤 3)重排序,但不允许非构造线程(这里指的是线程 2)看到这个重排序

