# 队列同步器AQS

> AQS `AbstractQueuedSynchronizer` 
>
> 是一个抽象的队列同步器,通过维护一个共享资源状态,和一个先进先出的线程等待队列来实现一个多线程共享资源的同步框架

主要使用方式是通过继承

获取同步状态就是获取到了锁

子类通过继承同步器并实现它的抽象方法来管理同步状态,锁和同步很好地隔离了使用者和实现者所关注的领域

很多并发工具都是基于 AQS的

- [ReentrantLock ](050-ReentrantLock.md) 
- [Semaphore ](../10-Java中的并发工具类/03-信号量-Semaphore.md) 
- [CountDownLatch](../10-Java中的并发工具类/01-CountDownLatch.md) 

等等

### 简介

AQS 为每一个共享资源都设置了一个共享资源锁,线程在需要访问共享资源的时候,首先需要获取共享资源锁,

- 如果获取到了共享资源锁,变可以在当前线程中使用该共享资源

- 如果获取不到,则将该线程放入线程等待队列,等待下一次资源调度

<img src="../../../assets/image-20200630230945550.png" alt="image-20200630230945550" style="zoom: 25%;" />

![image-20200701121558127](../../../assets/image-20200701121558127.png)

## 重要的概念

#### state:状态

维护了一个 volatile int 类型的变量,用于表示当前的同步状态

volatile 不能保证操作的原子性,但是能保证当前变量 state 的可见性

state 访问分为三种

- `getState();`
- `setState();`
- `compareAndSetState();`

均是原子操作,其中`compareAndSetState` 依赖`Unsafe 的` compareAndSwapInt()`

```java
/**
 * The synchronization state.
 */
private volatile int state;
```

### AQS 共享资源的方式: 独占式和共享锁

AQS定义了两种资源共享方式: 独立式 **(Exclusive)** 和共享式 (Share)

- 独立式: 只有一个线程能够执行,具体的 Java 实现由 `ReentrentLock`
- 共享式: 多个线程可同时执行,具体的 Java 实现由 `Semaphore` 和 `CountDownLatch`

AQS 仅仅只是一个框架,定义了一个接口,具体资源的获取,释放都交给自定义同步器去实现,不同的自定义同步器征用共享资源的方式也不同,自定义同步器在实现时只需要实现共享资源 state 的获取和释放方式即可,至于具体线程等待队列的维护,如获取资源失败入队,唤醒出队等,AQS已经在顶层实现好了,不需要具体的同步器再处理,需要实现的方法如下:

| 序号 | 方法名                      | 资源共享方式 | 说明                                                         |
| ---- | --------------------------- | ------------ | ------------------------------------------------------------ |
| 1    | `isHeldExclusively`         |              | 查询该线程是否正在独占资源,只有用到 condition 才需要去实现它 |
| 2    | `tryAcquire(int)`           | 独占方式     | 尝试获取资源,成功返回 true, 失败返回 false                   |
| 3    | `tryRelease(int arg)`       | 独占方式     | 尝试释放资源,成功返回 true, 失败返回 false                   |
| 4    | `tryAcquireShared(int arg)` | 共享方式     | 尝试获取资源,负数代表失败,0 代表成功,但是没有剩余可用资源;整数表示成功,且有剩余 |
| 5    | `tryReleaseShared(int arg)` | 共享方式     | 铲屎释放资源,如果释放资源后允许唤醒后续等待线程,返回 true.否则返回 false |

## 是什么

用来构建锁或者其他同步组件的基础框架,

- 内置一个 `FIFO` 队列来完成获取线程的排队工作
- 使用一个 `int` 成员变量表示同步状态



它基本上能够实现大部分同步需求的基础,

## 核心定义

同步器是锁(也可以是任意同步组件)的关键, 在锁的实现中聚合同步器, 利用同步器实现锁的语义.

可以这样理解两者之间的关系:

- 锁是面向使用者的,它定义了使用者与锁交互的接口(比如可以允许两个线程并行访问), 隐藏了实现细节
- 同步器面向的是锁的实现者,它**简化了锁的实现方式,屏蔽了同步状态管理**,**线程的排队**,**等待与唤醒**等底层操作
- 锁和同步器很好的隔离了**使用者**和**实现者**所关注的领域
  - 简化了锁的实现方式
  - 屏蔽了同步状态管理
  - 线程的排队
  - 等待与唤醒等底层操作

## 同步器的主要使用方法

继承 ,子类通过继承同步器并实现它的抽象方法来管理同步状态,同步器提供三个方法获取和设置同步状态

- `getState()`获取状态
- `setState(int newState) `设置一个新的状态
- `compareAndSetState(int expect, int update)` CAS 操作状态,原子方法

子类推荐定义为自定义同步组件的静态内部类,同步器自身没有实现任何同步接口,它仅仅是定义了**若干同步状态获取和释放的方法**来提供自定义同步组件使用,这样就有了自由度

- 自定义同步器可以支持度展示地获取同步状态
- 自定义同步器也可以支持共享地获取同步状态

这样就可以实现不同类型的同步组件( `ReentrantLock` , `ReentrantReadWriteLock` , `CountDownLatch`)等等

## 队列同步器的接口与示例

同步器的设计是基于模板方法模式的,也就是说,使用者需要继承同步器并重写指定的方法,随后将同步器组合在自定义同步组件的实现中,并调用同步器提供的模板方法,而这写模板方法将会调用使用者**重写**的方法

#### 抽象类中必要要重写的方法

| 方法名称                                      | 描述                                                         |
| --------------------------------------------- | ------------------------------------------------------------ |
| `protected boolean tryAcquire(int arg) `      | 独占式获取同步状态,实现该方法需要查询当前状态并判断同步状态是否符合预期,然后在进行 CAS 设置 |
| `protected int tryAcquireShared(int arg)`     | 共享式获取同步状态,返回大于等于 0 的值,表示获取成功,反之获取失败 |
| `protected boolean tryRelease(int arg)`       | 独占式释放同步状态,返回大于等于0的值,表示获取成功,反之获取失败 |
| `protected boolean tryReleaseShared(int arg)` | 共享式释放同步状态                                           |
| `protected boolean isHeldExclusively()`       | 当前同步器是否在独占模式下被线程占用,一般该方法表示是否被当前线程独占 |

#### 抽象类中写好的方法

实现自定义同步组件时,将会调用同步器提供的模板方法,这些(部分)模板方法:

| 方法名称                                                    | 描述                                                         |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| `void acquire(int arg)`                                     | 独占式获取同步状态,如果当前线程获取同步状态成功,则由该方法返回,否则,将会进入同步队列等待,该方法将会调用重写的`tryAcquire(int arg)` 方法 |
| `void acquireInterruptibly(int arg)`                        | 与`acquire(int arg)`相同,但是该方法响应中断,当前线程未获取到同步状态而进入同步对垒中,如果当前线程被中断,当前线程未获取到同步状态而进入同步队列中,如果当前线程被中断,则抛出`InterrupedException` |
| `boolean tryAcquireNanos(int arg, long nanosTimeout)`       | 在`acquireInterruptibly(int arg)` 基础上增加了超时限制,如果当前线程在超时时间内没有获取到同步状态,则返回 false, 获取到则返回 true |
| `void acquireShared(int arg)`                               | 共享式的获取同步状态,如果当前线程未获取到同步状态,将会进入同步队列中等待,与独占式获取的主要区别是在同一时刻可以有多个线程获取同步状态 |
| `void acquireSharedInterruptibly(int arg)`                  | 与`acquireShared(int arg)`方法相同,该方法相应中断            |
| `boolean tryAcquireSharedNanos(int arg, long nanosTimeout)` | 在`boolean acquireSharedInterruptibly(int arg)`基础上增加了超时限制 |
| `boolean release(int arg)`                                  | 独占式的释放同步状态,该方法会在释放同步状态之后,将同步队列中第一个节点包含的线程唤醒 |
| `void acquireShared(int arg) {`                             | 共享式释放同步状态                                           |
| `Collection<Thread> getQueuedThreads()`                     | 获取等待在同步队列上的线程集合                               |

基本上同步器的模板方法分为三类:

- 独占式获取与释放同步状态
- 共享式获取与释放同步状态
- 查询同步队列中的等待线程情况

## 一个独占锁的实例

独占锁是同一个时刻只能有一个线程获取到锁, 而其他获取锁的线程只能处于同步队列中等待, 只有获取锁的线程释放了锁, 后继的线程才能获取到锁

#### 声明静态内部类实现队列同步器

```java
/**
 * <p>
 * 自定义锁实现,用户使用 Mutex 的时候并不会直接和内部同步器的实现打交道,而是调用了</p>
 * </p>
 *
 * @author EricChen 2020/03/08 21:39
 */
public class Mutex {

    private final Sync sync = new Sync();

    public void lock() {
        sync.tryAcquire(1);
    }

    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    public void unlock() {
        sync.tryRelease(1);
    }

    public Condition newCondition() {
        return sync.newCondition();
    }

    public boolean isLock() {
        return sync.isHeldExclusively();
    }

    public boolean isQueuedThreads() {
        return sync.hasQueuedThreads();
    }

    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    public void tryLock(long timeout, TimeUnit timeUnit) throws InterruptedException {
        sync.tryAcquireNanos(1, timeUnit.toNanos(timeout));
    }


    /**
     * 集成同步器并重写指定的方法,随后将同步器组合在自定义的同步器组件中实现
     */
    static class Sync extends AbstractQueuedSynchronizer {

        /**
         * @return 是否独占
         */
        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        /**
         * 当状态为 0 的时候获取锁
         *
         * @return 0
         */
        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            if (getState() == 0) {
                throw new IllegalArgumentException();
            }
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }
    }
}

```

## 同步队列的实现分析

- 同步队列
- 独占式同步状态获取与释放
- 共享式同步状态状态获取与释放
- 超时获取同步状态

#### 同步队列

同步器内部维护了一个双向队列(FIFO) 来完成同步状态的管理

- 当前线程获取同步状态失败: 会将当前线程以及等待状态等信息构造成一个节点(Node)并加入同步队列,阻塞线程
- 当同步状态释放时,会把首节点中的线程唤醒,使其再次尝试获取同步状态

这里 Node 概念用来保存获取同步状态失败的线程引用,等待状态以及前驱和后继节点

#### Node节点的属性

<img src="../../../assets/image-20200308221536782.png" alt="image-20200308221536782" style="zoom: 50%;" />

#### 同步队列的基本结构图

<img src="../../../assets/image-20200308221643509.png" alt="image-20200308221643509" style="zoom: 50%;" />

当一个线程成功的获取到同步状态(或者锁),那么其他线程就无法获取到,这个时候他们会被构建成 node放到同步队列的尾端,加入队列的过程必须要保证线程安全,说以使用了一个基于 CAS 的设置尾结点的方法:	吧是参                                    

```java
/**
     * CAS tail field. Used only by enq.
     */
private final boolean compareAndSetTail(Node expect, Node update) {
  return unsafe.compareAndSwapObject(this, tailOffset, expect, update);
}
```

<img src="../../../assets/image-20200308222242429.png" alt="image-20200308222242429" style="zoom: 50%;" />

当首节点释放同步状态时,将会唤醒后继节点,后继节点将会在获取同步状态成功后将自己设置为首节点

<img src="../../../assets/image-20200308222416572.png" alt="image-20200308222416572" style="zoom: 50%;" />

由于只有一个线程能够成功获取到同步状态,所以设置头节点的方法不需要使用 CAS 来保证,它只需要将首节点设置成原节点的后继节点并断开原首页节点的 next 引用即可

#### 独占式同步状态获取与释放

通过调用同步器 `acquire(int arg)` 方法可以获取同步状态,对中断不敏感,由于线程获取同步状态失败后进入同步对垒,后续对线程进行中断操作时,线程不会从同步队列移出



> 
>
> ```java
> public final void acquire(int arg) {
>   if (!tryAcquire(arg) &&
>       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
>     selfInterrupt();
> }
> ```
>
> - 同步状态获取
> - 节点构造
> - 加入同步队列
> - 在同步队列中自旋

主要逻辑是: 

- [调用自定义实现的 `tryAcquire(int arg)` 方法,线程安全地获取同步状态](#调用自定义实现的 `tryAcquire(int arg)` 方法,线程安全地获取同步状态)
  - [如果同步状态获取失败,则构造同步节点(独占式节点 Node.EXCLUSIVE,同一时刻只能有一个线程成功地获取同步状态)](#节点构造以及加入同步队列)
- 调用`addWaiter(Node node)` 方法将刚刚构造的节点加入到同步队列的尾部
- 调用`boolean acquireQueued(final Node node, int arg) ` 方法,使得该节点以"死循环"的方式获取同步状态
  - 如果获取不到则阻塞节点中的线程,而被阻塞线程的唤醒主要依靠**前驱节点的出队或者阻塞队列中被中断来实现**

#### 调用自定义实现的 `tryAcquire(int arg)` 方法,线程安全地获取同步状态

tryAcquire 为不同的子类自己实现

```java
    protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
```

我们看一下 FairSync 实现

```java
        /**
         * Fair version of tryAcquire.  Don't grant access unless
         * recursive call or no waiters or is first.
         */
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                  //获取到同步状态,实际上就是获取到锁
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
              //如果当前线程是已经获取到现成的独占锁
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
              //设置state 类型,标识重入次数  
              setState(nextc);
                return true;
            }
          //获取不到锁
            return false;
        }
```

##### 节点构造以及加入同步队列

```java
    /**
     * Creates and enqueues node for current thread and given mode.
     *
     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
     * @return the new node
     */
    private Node addWaiter(Node mode) {
    //把当前线程封装到 Node 节点中
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        //将前节点设置为尾部
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
            //替换尾部节点
                pred.next = node;
                return node;
            }
        }
        //入列,但是尾部节点为空
        enq(node);
        return node;
    }


/**
     * Inserts node into queue, initializing if necessary. See picture above.
     * @param node the node to insert
     * @return node's predecessor
     通过死循环确保节点的正确添加,在死循环中只有通过 CAS 将节点设置成为尾结点以后,当前线程才能从该方法返回,否则当前线程会不断尝试设置
     实际上 enq 方法将并发添加节点的请求通过 CAS 变得串行化了
     */
    private Node enq(final Node node) {
        for (;;) {//自旋
            Node t = tail;
          //获取到尾节点,如果尾节点为空,说明队列里没有 Node
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))//设置头
                //设置头节点为尾结点
                    tail = head;
            } else {
              //如果存在尾结点,说明有节点,这个时候塞到尾巴
                node.prev = t;
                if (compareAndSetTail(t, node)) {
//compareAndSetTail 方法确保节点能够被线程安全的添加             
                    t.next = node;
                    return t;
                }
            }
        }
    }


```

- `compareAndSetTail` 方法确保节点能够被线程安全的添加            
- `enq方法:`通过死循环确保节点的正确添加,在死循环中只有通过 CAS 将节点设置成为尾结点以后,当前线程才能从该方法返回,否则当前线程会不断尝试设置
   实际上 enq 方法将并发添加节点的请求通过 CAS 变得串行化了
-  节点进入同步队列后,**进入自旋过程**,每个节点都在自省地观察,当条件满足,获取到了同步状态,就可以从这个自旋过程中退出,否则依旧自旋(并会阻塞节点的线程)

```java
    /**
     * Acquires in exclusive uninterruptible mode for thread already in
     * queue. Used by condition wait methods as well as acquire.
     *
     * @param node the node
     * @param arg the acquire argument
     * @return {@code true} if interrupted while waiting
     */
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
              //进入自旋死循环
                final Node p = node.predecessor();//获取形参节点的前驱
                if (p == head && tryAcquire(arg)) {
                  //如果前驱节点是 head 且可以获取到同步状态,
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
              //判断是否需要将线程置为等待状态
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    /**
     * Checks and updates status for a node that failed to acquire.
     * Returns true if thread should block. This is the main signal
     * control in all acquire loops.  Requires that pred == node.prev.
     *
     * @param pred node's predecessor holding status
     * @param node the node
     * @return {@code true} if thread should block
     */
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             如果前驱节点的状态是 SINGNAL ,说明要通知后续节点获取线程
             */
            return true;
        if (ws > 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             前驱节点被取消了,跳过前驱几点
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

```

`acquireQueued`方法中,当前线程在死循环中尝试获取同步状态,而只有前驱节点是头节点才能够尝试获取同步状态,为什么?

- 头结点是成功获取到同步状态的节点, 头节点的线程释放了同步状态之后,将会唤醒器后继节点,后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点
- 维护同步队列的 FIFO 原则,该方法中,节点自旋获取同步状态,下图

![image-20200701121138837](../../../assets/image-20200701121138837.png)

- 非头点节点的前驱节点出队或者被中断 导致从等待状态返回
- 检查自己的前驱节点是否是头结点,如果是,则尝试获取同步状态

>  可以看到节点和节点之间是在循环检查的过程中基本不互相通信,而是简单地判断自己的前驱是否是头节点
>
> - 保证释放规则符合 FIFO
> - 保证过早通知(过早通知是指前驱节点不是头节点的线程由于终端被唤醒)的处理



## 独占式同步状态获取流程

- 自旋的作用
  - 判断是否前驱节点是头结点,且能够获取同步状态 ,  则退出自旋
  - 也不是一直自旋,如果线程被中断或者前驱节点被释放,则从等到状态返回
- 当获取同步状态成功时,也代表着当前线程获取到了锁

![image-20200701121558127](../../../assets/image-20200701121558127.png)



## 独占式释放同步状态

`release 方法`可以释放同步状态,释放同步状态后,会唤醒其后继节点(进而使后继节点重新尝试获取同步状态)

```java
    /**
     * Releases in exclusive mode.  Implemented by unblocking one or
     * more threads if {@link #tryRelease} returns true.
     * This method can be used to implement method {@link Lock#unlock}.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryRelease} but is otherwise uninterpreted and
     *        can represent anything you like.
     * @return the value returned from {@link #tryRelease}
     */
    public final boolean release(int arg) {
        if (tryRelease(arg)) {
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);//唤醒后续节点
            return true;
        }
        return false;
    }

```

调用的是 AQS 实现类的`tryRelease`

```java
        protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
```

尝试释放状态,实际上就是释放了STATUS进行减操作

`unparkSuccessor(h);//唤醒后续节点`

```java
    private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);//使用工具类唤处于等待状态的线程
    }
```

#### 总结

在获取同步状态时,同步器维护一个同步队列,

- 获取状态失败的线程都会被加入到队列中并在队列中进行自旋,使用`shouldParkAfterFailedAcquire`判断是否需要`park`,然后调用`parkAndCheckInterrupt`进行 `park`

- 移出队列(或者停止自旋)的条件是前驱节点为头节点且成功获取了同步状态

- 在释放同步状态时,同步器调用 `tryRealease(int arg)` 方法释放同步状态,然后唤醒后续节点

## 共享式同步状态获取

共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态.

以文件读写为例:

- 如果一个程序在对文件进行读操作,那么其他程序写被 **阻塞**, 读 允许
- 写操作要求对资源的独占式访问,而读操作可以是共享式访问

<img src="../../../assets/image-20200326204730689.png" alt="image-20200326204730689" style="zoom: 33%;" />

> - 左半部分为共享式访问资源 **小册,大厅,可以被看**
>
> - 又半部分是独占式访问资源,同一时刻其他访问均被访问 , **上大策,包房,不能被看**

`acquireShared`方法用来释放共享式同步状态

- `tryAcquireShared`,同步工具重写,返回大于 0 则表示能够获取同步状态

```java
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0) //tryAcquireShared,同步工具重写,返回大于 0 则表示能够获取同步状态
            doAcquireShared(arg);
    }
    
    
    /**
     * Acquires in shared uninterruptible mode.
     * @param arg the acquire argument
     * 通过自旋,如果当前节点的前驱是头结点,尝试获取同步状态,如果返回值>=0,表示该次获取同步状态成功并从自旋过程退出
     */
    private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();//前节点的的前驱
                if (p == head) {//如果前驱是头节点
                    int r = tryAcquireShared(arg);//尝试获取同步状态
                    if (r >= 0) {//获取同步状态成功
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) && 
                    parkAndCheckInterrupt())//判断是否需要park,然后调用 parkAndCheckInterrupt进行 park
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

## 共享式同步状态释放

```java
    /**
     * Releases in shared mode.  Implemented by unblocking one or more
     * threads if {@link #tryReleaseShared} returns true.
     *
     * @param arg the release argument.  This value is conveyed to
     *        {@link #tryReleaseShared} but is otherwise uninterpreted
     *        and can represent anything you like.
     * @return the value returned from {@link #tryReleaseShared}
     */
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
```

释放同步状态以后,将会唤醒后续出于等待的节点,

对于能够支持多个线程同时访问的并发组件(Semaphore) ,它和独占式的主要区别在于`tryReleaseShared`方法必须确保同步状态,或者资源,安全释放

一般通过循环和 CAS 来保证,因为释放状态的操作会来自多个线程

> 例如在 `cn.eccto.study.java.concurrent.art.chapter05.TwinsLock`中
>
> ```
>         @Override
>         protected boolean tryReleaseShared(int count) {
>             //自旋方式去释放资源,确保释放完
>             for (; ; ) {
>                 //首先判断目前的状态
>                 int current = getState();
>                 int remain = current + count;
>                 if (compareAndSetState(count, remain)) {
>                     return true;
>                 }
>             }
>         }
> ```
>
> 

```java
/**
 * Release action for shared mode -- signals successor and ensures
 * propagation. (Note: For exclusive mode, release just amounts
 * to calling unparkSuccessor of head if it needs signal.)
 */
private void doReleaseShared() {
    /*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     */
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```

## 独占式超时获取同步状态

`doAcquireSharedNanos`方法可以超时获取同步状态,即在指定时间内获取同步状态

- 如果指定时间内获取不到,返回 false
- 如果指定时间内获取到了,返回 true

该方法提供了传统 Java 同步操作(比如 Synchrionzied 不具备的特性)

```java
    /**
     * Acquires in shared timed mode.
     *
     * @param arg the acquire argument
     * @param nanosTimeout max wait time
     * @return {@code true} if acquired
     */
    private boolean doAcquireSharedNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        if (nanosTimeout <= 0L)
            return false;
        final long deadline = System.nanoTime() + nanosTimeout; // 超时时间
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return true;
                    }
                }
                nanosTimeout = deadline - System.nanoTime();
                if (nanosTimeout <= 0L)
                    return false;
                if (shouldParkAfterFailedAcquire(p, node) &&
                    nanosTimeout > spinForTimeoutThreshold)
                    LockSupport.parkNanos(this, nanosTimeout);
                if (Thread.interrupted())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

<img src="../../../assets/image-20200701125612583.png" alt="image-20200701125612583" style="zoom: 50%;" />

- acquire (int args) 在未获取到同步状态时,线程一直处于等待状态
- doAcquireNanos(int arg, long nanosTimeout) 会使得当前线程等待 nanosTimeout 纳秒,如果当前在nanosTimeout 内没有获取到同步状态,将会自动返回