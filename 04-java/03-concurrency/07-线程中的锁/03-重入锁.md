# 重入锁 ReentrantLock,(公平锁,非公平锁)

支持重入的锁,表示该锁能支持一个线程对资源的重复加锁,`syschronized`修饰的递归方法,在方法执行时,执行线程在获取了锁之后仍然能多次连续的获取锁

- 公平锁 : 在绝对时间上,先对锁进行获取的请求一定先被满足,等待时间最长的线程最优先获取锁
- 非公平锁 . 反之

### 实现重入

重进入是指,任意线程在获取到锁之后能够再次获取该锁,而不被锁阻塞,该特性的实现需要解决一下两个问题:

- **线程再次获取锁**,锁需要去识别锁的线程数会否为当前占据的线程,如果是,则再次成功获取
- **锁的最终释放**: 线程重复 n 次获取了锁,随后在第 n 次释放该锁后,其他线程能够获取到该锁,锁的最终释放要求锁对于获取进行计数自增,计数表示当前锁被重复获取的次数,而锁被释放时,当计数等于0 时表示锁已经被成功释放



### 获取逻辑

![image-20200326212943035](assets/image-20200326212943035.png)

- 通过判断当前线程是否为获取锁的线程来决定获取操作是否成功
  - 如果是获取锁的线程再次请求,则将同步状态值增加并返回 true 表示获取同步状态成功
  - 成功获取锁的线程再次获取锁,只是增加了同步状态值

#### 释放逻辑

![IMG_59A5D2671218-1](assets/IMG_59A5D2671218-1.jpeg)

- 如果该锁被获取了 n 次,那么前(n-1) 次 tryRealease(int realease) 方法必须返回 false, 而只有同步状态完全释放了,才能返回 true
- 该方法将同步状态是否为 0 作为最终释放的条件,将占有线程设置为 null, 并返回 true

## 公平锁与非公平锁比较

- 非公平锁效率比公平锁高,因为 **线程切换的损耗** ,吞吐量更大 ,因为释放的时候,刚释放的线程再一次获取同步状态的几率大
- 非公平锁在获取时直接使用 CAS 去获取锁, 公平锁要先对比是否队列中有其他在等待