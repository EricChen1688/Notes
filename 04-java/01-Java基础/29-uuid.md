# Java UUID Generator Example

Learn what is UUID and it’s versions and variants. Learn to generate **UUID in Java** using UUID.randomUUID() API. Also learn to **generate version 5 UUID in Java**.

## 1. What is UUID?

**UUID** (*Universally Unique IDentifier* 全局惟一标识符), also known as **GUID** (*Globally Unique IDentifier*) is `128 bits` long identifier that is unique across both space and time, with respect to the space of all other UUIDs. It requires no central registration process. As a result, generation on demand can be completely automated, and used for a variety of purposes.

To understand **how unique is a UUID**, you should know that UUID generation algorithms support very high allocation rates of up to *10 million per second* per machine if necessary, so that they could even be used as transaction IDs.

We can apply sorting, ordering and we can store them in databases. It makes it useful in programming in general.

Since UUIDs are unique and persistent, they make excellent *Uniform Resource Names (URNs)* with lowest mining cost in comparison to other alternatives.

*The **nil UUID** is special form of UUID that is specified to have all 128 bits set to zero.*

> Do not assume that UUIDs are hard to guess; they should not be used as security capabilities. A predictable random number source will exacerbate the situation. Humans do not have the ability to easily check the integrity of a UUID by simply glancing at it.

## 2. UUID Types

A typical UID is displayed in **5 groups** separated by hyphens, in the form 8-4-4-4-12 for a total of 36 characters (**32 alphanumeric characters and 4 hyphens**).

> 123e4567-e89b-12d3-a456-426655440000
> xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx

Here `'M'` indicate the **UUID version** and `'N'` indicate the **UUID variant**.

- The **variant** field contains a value which identifies the layout of the UUID.
- The version field holds a value that describes the type of this UUID. There are five different basic types of UUIDs.
  1. Time-Based UUID (Version 1) – generated from a time and a node id
  2. DCE (Distributed Computing Environment) security (Version 2) – generated from an identifier (usually a group or user id), time, and a node id
  3. Name-based (Version 3) – generated by [MD5](https://howtodoinjava.com/java/io/how-to-generate-sha-or-md5-file-checksum-hash-in-java/) (128 bits) hashing of a namespace identifier and name
  4. Randomly generated UUIDs (Version 4) – generated using a random or pseudo-random number
  5. Name-based using SHA-1 hashing (Version 5) **Recommended** – generated by [SHA-1](https://howtodoinjava.com/security/how-to-generate-secure-password-hash-md5-sha-pbkdf2-bcrypt-examples/) (160 bits) hashing of a namespace identifier and name. Java does not provide its implementation. We shall create our own.

> UUID具有多个版本，每个版本的算法不同，应用范围也不同。首先是一个特例－－Nil UUID－－通常我们不会用到它，它是由全为0的数字组成：00000000-0000-0000-0000-000000000000
>
> ### 基于时间的UUID
>
> 基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。
>
> ### DCE安全的UUID
>
> DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。
>
> ### 基于名字的UUID（MD5）
>
> 基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。
>
> ### 随机UUID
>
> 根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的。
>
> ### 基于名字的UUID（SHA1）
>
> 和基于名字的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。

## 3. Java UUID Example

#### 3.1. UUID.randomUUID() – Version 4

Default API `randomUUID()` is a static factory to retrieve a type 4 (pseudo randomly generated) UUID. It is good enough for most of the usecases.

```java
UUID uuid = UUID.randomUUID();
         
System.out.println(uuid);
System.out.println(uuid.variant());     //2
System.out.println(uuid.version());     //4
```

Program output.

```
17e3338d-344b-403c-8a87-f7d8006d6e33
2
4
```

#### 3.2. Generate Version 5 UUID

Java does not provide inbuilt API to generate version 5 UUID, so we have to create our own implementation. Below is one such implementation. ([Ref](https://github.com/rootsdev/polygenea/blob/master/java/src/org/rootsdev/polygenea/UUID5.java)).

```java
import java.nio.ByteOrder;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.UUID;
 
public class UUID5 
{
    public static UUID fromUTF8(String name) {
        return fromBytes(name.getBytes(Charset.forName("UTF-8")));
    }
     
    private static UUID fromBytes(byte[] name) {
        if (name == null) {
            throw new NullPointerException("name == null");
        }
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            return makeUUID(md.digest(name), 5);
        } catch (NoSuchAlgorithmException e) {
            throw new AssertionError(e);
        }
    }
     
    private static UUID makeUUID(byte[] hash, int version) {
        long msb = peekLong(hash, 0, ByteOrder.BIG_ENDIAN);
        long lsb = peekLong(hash, 8, ByteOrder.BIG_ENDIAN);
        // Set the version field
        msb &= ~(0xfL << 12);
        msb |= ((long) version) << 12;
        // Set the variant field to 2
        lsb &= ~(0x3L << 62);
        lsb |= 2L << 62;
        return new UUID(msb, lsb);
    }
     
    private static long peekLong(final byte[] src, final int offset, final ByteOrder order) {
        long ans = 0;
        if (order == ByteOrder.BIG_ENDIAN) {
            for (int i = offset; i < offset + 8; i += 1) {
                ans <<= 8;
                ans |= src[i] & 0xffL;
            }
        } else {
            for (int i = offset + 7; i >= offset; i -= 1) {
                ans <<= 8;
                ans |= src[i] & 0xffL;
            }
        }
        return ans;
    }
}
```

```
UUID uuid = UUID5.fromUTF8("954aac7d-47b2-5975-9a80-37eeed186527");
 
System.out.println(uuid);
System.out.println(uuid.variant());
System.out.println(uuid.version());
```

```
d1d16b54-9757-5743-86fa-9ffe3b937d78
2
5
```

