OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。

每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi幻境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当受到类加载请求时，OSGi将按照下面的顺序进行类搜索：

- 1）将java.＊开头的类委派给父类加载器加载。 
- 2）否则，将委派列表名单内的类委派给父类加载器加载。
- 3）否则，将**Import**列表中的类委派给**Export**这个类的Bundle的类加载器加载。 
- 4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。 
- 5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。 
- 6）否则，查找**Dynamic** **Import**列表的Bundle，委派给对应Bundle的类加载器加载。 
- 7）否则，类加载器失败。

