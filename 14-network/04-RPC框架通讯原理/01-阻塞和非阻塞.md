# 阻塞(Block)和非阻塞(Non-Block)

阻塞和非阻塞是进程在访问数据的过程中,数据是否准备就绪的一种方式,当数据没有准备的时候

- 阻塞: 需要等待缓冲区中的数据准备好之后才能处理其他事情,否则一直等待在那里
- 非阻塞: 当我们的进程访问我们的数据缓冲区的时候,如果没有准备好数据则直接返回,不会进行等待,如果数据已经准备好,也直接返回

## 同步(Synchronziation)和异步 Asynchronous

同步和异步都是基于应用程序和操作系统处理 IO 事件所采用的方式

- 同步: 应用程序直接参与 IO 读写的操作
- 异步: 所有的 IO 读写交给操作系统去处理,应用程序值需要等待通知

同步方式在处理 IO 事件的时候,必须阻塞在某个方法上面等待我们的 IO 事件完成(阻塞 IO 事件或者通过轮询 IO 事件的方式)

异步方式,所有的 IO 读写都交给操作系统,这个时候我们可以去做其他的事情,并不需要去完成真正的 Io

## 阻塞 IO 和 非阻塞 IO

阻塞 IO 模型是常见的 IO 模型,在读写数据的时候客户端会发生阻塞,阻塞 I/O 模型的工作流程为: 在用户线程发出 I/O 请求后,内核会检查数据是否准备就绪,此时用户线程一直阻塞等待内存数据就绪

- 内存就绪后,内核将数据复制到用户线程中,并返回 I/O 执行结果到用户线程,此时用户线程将解除阻塞状态并开始处理数据
- 如果内核数据没有就绪,Socket 线程就会一直阻塞在 read()等待内核数据就绪

典型的阻塞 IO 模型的例子为

```java
data= socket.read();
```

非阻塞 IO 模型指的是用户线程在发起一个 I/O操作之后,无需则色变可以马上得到内核返回的一个结果

- 如果内核数据还没有准备好,返回的是 false,需要稍后发送 I/O操作
- 如果内核数据准备好了,内核就会立刻将数据复制到用户线程中并将复制的结果通知用户线程

在非阻塞 IO 模型中,用户线程需要不断询问内核数据是否就绪,在内存数据还没有就绪的时候,用户线程可以处理其他任务,在内核数据就绪之后可以立即获取数据并进行 相应的操作

典型的非阻塞IO 模型为

```java
while(true){
	data= socket.read();
	if(data == true){
	//内核主内就绪
	break;
	}else{
		//内核没有准备就绪,用户线程处理其他线程
	}
	
}
```

## BIO 和 NIO 的对比

下表总结了 Java BIO(Block IO)和 NIO(Non-Block IO)之间的主要差别异。

| IO 模型 | BIO            | NIO                        |
| ------- | -------------- | -------------------------- |
| 通讯    | 面向流         | 面向缓冲                   |
| 处理    | 阻塞 IO 多线程 | 非阻塞 IO (反应堆 Reactor) |
| 触发    | 无             | 选择器(轮询机制)           |

#### 面向流与面向缓冲

Java NIO 和 BIO 之间第一个最大的区别是，BIO 是面向流的，NIO 是面向缓冲区的。 Java BIO 面向流意味着每
次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。 如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO 的缓冲导向方法略有不同。数据读取 到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是 否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的 数据。

#### 阻塞与非阻塞

Java BIO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被
读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO 的非阻塞模式，使一个线程从某通道发送请 求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞， 所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到 某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它 通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道(channel)。

#### 选择器的问世

Java NIO 的选择器(Selector)允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道:这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制， 使得一个单独的线程很容易来管理多个通道。