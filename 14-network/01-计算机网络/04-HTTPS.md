# HTTPS

由于 HTTP 协议在通信过程中，是基于明文通信，并且底层是基于 TCP/IP 协议进行通信，那 么按照 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到拦截和窃取。 窃取这个过程其实很简单，通过抓包工具 Wireshark 就可以截获请求和响应的内容

由于 HTTP 协议通信的不安全性，所以人们为了防止信息在传输过程中遭到泄漏或者篡改， 就想出来对传输通道进行加密的方式 https。

https 是一种加密的超文本传输协议，它与 HTTP 在协议差异在于对数据传输的过程中，https 对数据做了完全加密。由于 http 协议或者 https 协议都是处于 TCP 传输层之上，同时网络协 议又是一个分层的结构，所以在 tcp 协议层之上增加了一层 **SSL(Secure Socket Layer**，安 全层)或者 **TLS(Transport Layer Security)** 安全层传输协议组合使用用于构造加密通道;

## 什么是 SSL 和 TLS

Ssl 是 netscape 公司设计的(Secure sockets layer)，后来互联网标准化组织 ISOC 接替了 NETScape 公司，发布了 SSL 的升级版 TLS。接着 TLS 的版本又进行了多次升级; 实际上我 们现在的 HTTPS 都是用的 TLS 协议，但是由于 SSL 出现的时间比较早，并且依旧被现在浏 览器所支持，因此 SSL 依然是 HTTPS 的代名词。

![image-20200329165038079](assets/image-20200329165038079.png)









Https 是在 http 的基础上加了 SSL 层来提高数据传输安全性,SSL 依靠证书来校验服务器的身份,并对浏览器和服务器之间的通讯进行数据加密,以保障数据传输的安全性,端口 443

- 发送请求

客户端通过 TCP和服务端建立连接后,发出一个请求证书的消息给服务器,在请求头里会加上自己可以实现的算法列表以及其他信息

- 证书返回

服务端接受到消息后返回证书,证书中包含服务器信息,域名,注册公司,公钥,数据加密算法等

- 证书校验
  - 客户端收到证书后,判断证书签发机构是否正确,
  - 判断证书签发机构的公钥确定签名是否有效
  - 判断证书中列出的域名是否是正在连接的域名
  - 以上都正确,生成对称秘钥,并使用公钥将对称秘钥加密

- 密钥交换

客户端将加密后的对称秘钥发送给服务端,服务端在接受到对称秘钥后使用私钥解密

- 数据传输

使用对称加密进行通讯,加密和解密使用相同的秘钥的加密算法

## 逆向推导 https 的设计过程

- 裸奔, 不带任何加密算法
- 对称加密
  - 如果所有浏览器都使用同一个密钥,跟裸奔无异
  - 如果每个客户端生成不同的秘钥, 那么在建立连接的时候,肯定有协商算法的过程,这个过程是明文的,不安全
- 非对称加密
  - 传输过程,公钥有可能会被掉包
- 第三方机构(https CA)

## HTTPS 交互过程

https 应用实战

1. 客户端发起请求(Client Hello 包)
  - 三次握手，建立 TCP 连接 
  - 支持的协议版本(TLS/SSL)
  - 客户端生成的随机数  client.random，后续用于生成“对话密钥”
  -  客户端支持的加密算法
  - sessionid，用于保持同一个会话(如果客户端与服务器费尽周折建立了一个 HTTPS 链接， 刚建完就断了，也太可惜)
2. 服务端收到请求，然后响应(Server Hello)
  - 确认加密通道协议版本
  - 服务端生成的随机数 server.random，后续用于生成“对话密钥” 
  - 确认使用的加密算法(用于后续的握手消息进行签名防止篡改) 
  - 服务器证书(CA 机构颁发给服务端的证书)
3. 客户端收到证书进行验证
  1. 验证证书是否是上级 CA 签发的, 在验证证书的时候，浏览器会调用系统的证书管理器
    接口对证书路径中的所有证书一级一级的进行验证，只有路径中所有的证书都是受信的，
    整个验证的结果才是受信
  2. 服务端返回的证书中会包含证书的有效期，可以通过失效日期来验证 证书是否过期
  3. 验证证书是否被吊销了
  4. 前面我们知道 CA 机构在签发证书的时候，都会使用自己的私钥对证书进行签名
    证书里的签名算法字段 sha256RSA 表示 CA 机构使用 sha256 对证书进行摘要，然后 使用 RSA 算法对摘要进行私钥签名，而我们也知道 RSA 算法中，使用私钥签名之后， 只有公钥才能进行验签。
  5. 浏览器使用内置在操作系统上的 CA 机构的公钥对服务器的证书进行验签。确定这个证 书是不是由正规的机构颁发。验签之后得知 CA 机构使用 sha256 进行证书摘要，然后 客户端再使用 sha256 对证书内容进行一次摘要，如果得到的值和服务端返回的证书验 签之后的摘要相同，表示证书没有被修改过
  6. 验证通过后，就会显示绿色的安全字样
  7. 客户端生成随机数，验证通过之后，客户端会生成一个随机数 pre-master secret，客户
    端根据之前的:`Client.random + sever.random + pre-master` 生成对称密钥然后使用证书中的公钥进行加密，同时利用前面协商好的 HASH 算法,把握手消息取 HASH 值， 然后用 随机数加密 “握手消息+握手消息 HASH 值(签名)” 并一起发送给服务端 (在 这里之所以要取握手消息的 HASH 值，主要是把握手消息做一个签名，用于验证握手 消息在传输过程中没有被篡改过。)

4. 服务端接收随机数
  1. 服务端收到客户端的加密数据以后，用自己的私钥对密文进行解密。然后得到
    `client.random/server.random/pre-master secret`, HASH 值，并与传过来的 HASH 值做
    对比确认是否一致。
  2.  然后用随机密码加密一段握手消息(握手消息+握手消息的 HASH 值 )给客户端
5. 客户端接收消息
  1. 客户端用随机数解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此
    时握手过程结束，
  2. 之后所有的通信数据将由之前交互过程中生成的` pre master secret /client.random/server.random` 通过算法得出 session Key，作为后续交互过程中的对称 密钥

