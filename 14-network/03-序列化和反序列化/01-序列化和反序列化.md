# 序列化和反序列化

## 目录

------

[TOC]

## 序列化的含义、意义及使用场景

- **序列化：将对象写入到IO流中**
- **反序列化：从IO流中恢复对象**
- **意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。**
- **使用场景：所有可在网络上传输的对象都必须是可序列化的，**比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；**所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。**

## **Java序列化算法**

1. **所有保存到磁盘的对象都有一个序列化编码号**
2. **当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。**
3. **如果此对象已经序列化过，则直接输出编号即可。**

![img](../../assets/1603499-20190521180352659-740977206.jpg)

## 什么序列化,为什么我们要序列化

Java 对象在 JVM 运行的时候被创建, 更新, 或者销毁, 当 JVM 退出时,对象也会随之销毁

在现实应用中,我们常常需要将对象以及其状态在多个应用之间传递, 共享, 例如在一个应用中将对象以及其状态持久化, 在其他地方重新读取被保存的对象以及其状态继续进行处理

**序列化就是将对象以及其状态保存成一组字节数组中,其中**

- **序列化和反序列化必须序列化 ID 一致**,如果不一致会报错,没有写,jvm 会默认生成一个(安全校验)

```java
private static final long serialVersionUid = 1234567889L
```

- **静态变量不会被序列化**
- **transient 修饰的变量不会被序列化**
- 可以通过写` writeObject `方法和 `readObject` 方法定制序列化实现

## 开发中怎么实现序列化

- 对象实现`Serializable`接口, 可以实现默认的序列化机制,可以通过定义`writeObject` 和 `readObject`来自定义序列化的实现

- 对象实现 `Externalizable` 接口, 重写`writeExternal`方法和`readExternal`方来定义序列化的实现

## Transient

Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变 量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。

#### 绕开 transient 机制的办法

在标有 transient 在序列化时会被忽略,我们可以通过在实体类中写`writeObject`方法和`readObject`方法在自定义序列化机制

#### writeObject 和 readObject 原理

writeObject 和 readObject 是两个私有的方法，他们是`ObjectInputStream` 和 `ObjectOutPutStream`中触发的

![image-20200329201332803](../../assets/image-20200329201332803.png)

readObject 方法会在反序列化时通过反射调用

![image-20200329201426798](../../assets/image-20200329201426798.png)

## Java序列化总结

1. Java 序列化只是针对对象的状态进行保存，至于对象中的方法，序列化不关心
2. 当一个父类实现了序列化，那么子类会自动实现序列化，不需要显示实现序列化接口
3. 当一个对象的实例变量引用了其他对象，序列化这个对象的时候会自动把引用的对象也进
 行序列化(实现深度克隆),引用对象也需要实现序列化接口
4. 当某个字段被申明为 transient 后，默认的序列化机制会忽略这个字段
5. 被申明为 transient 的字段，如果需要序列化，可以添加两个私有方法:writeObject 和 readObject

