# [0138-复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

## 时间复杂度

O(n)

## 空间复杂度



## 解决方案

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null){
            return null;
        }
        Map<Node,Node> map = new HashMap<>();
        Node newHead = head;
        //遍历一遍,将 val取出
        while(newHead != null) {
            if(!map.containsKey(newHead)){
                map.put(newHead,new Node(newHead.val));
            }
            if(newHead.random != null) {
                Node random = newHead.random;
                if(!map.containsKey(random)) {
                    map.put(random,new Node(random.val));
                }
                map.get(newHead).random = map.get(random)	;
            }
            newHead = newHead.next;
        }
        newHead = head;
        while (newHead != null){
            Node next = newHead.next;
            map.get(newHead).next = map.get(next);
            newHead = newHead.next;
        }
        return map.get(head);
    }
```

## 优化后

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        if (head == null || m > n) {
            return null;
        }
        //dummy
        ListNode dummy = new ListNode(-1); 
        dummy.next = head;
        head = dummy;
        //找到m前一个节点 prevM
        ListNode prevM = head;
        ListNode mNode = head;
        for (int i = 0; i < m-1; i++) {
            prevM = prevM.next;
        }
        //找到m节点  mNode
        mNode = prevM.next;
        //找到 n 节点 nNode
        //找到 n 节点的后续节点 postN
        ListNode nNode = mNode;
        ListNode postN = nNode.next;
        for (int i = m; i < n; i++) {
            ListNode next = postN.next;
            postN.next = nNode;
            nNode = postN;
            postN = next;
        }
        //翻转
        //把m的前一个节点的 next 指向 n节点
        prevM.next = nNode;
        //把m节点的next指向n 的next
        mNode.next = postN;
        return dummy.next;

    }
}
```

