# 060-热点问题

[TOC]

## 字符串常量池放在哪里

字符串常量池

- JDK8之后放入了元空间
- JDK7放在堆中
- JDK7之前放在了永久代



JVM 的内存模型只是一个规范，方法区也是一个规范，一个逻辑分区，并不是一个物理空间，我们这里说的字符串常量放在堆内存空间中，是指实际的物理空间。

## 栈上分配, 对局部变量对象大小是否有要求

目前 Hotspot 虚拟机暂时不支持栈上分配对象

- Java只有值传递, 跨方法的局部变量在站上分配的话, 在现有栈实现上会影响栈的回收
- 栈属于线程所有,  实现栈上分配, 会消耗更多的内存, 让Java的多线程更加吃内存
- 如果实现栈上分配, 还需要GC作用会弱化很多

- 基类型站上分配 + 引用类型堆分配-> 全栈上分配, 这么实现的hotspot感觉全推翻了

## minor gc是否会导致stw

## major gc是什么是否发生, 它和full gc的区别是什么

不管什么 GC，都会发送 stop-the-world，区别是发生的时间长短。而这个时间跟垃圾收集器又有关系，Serial、PartNew、Parallel Scavenge 收集器无论是串行还是并行，都会挂起用户线程，而 CMS 和 G1 在并发标记时，是不会挂起用户线程的，但其它时候一样会挂起用户线程，stop the world 的时间相对来说就小很多了。

Major Gc 在很多参考资料中是等价于 Full GC 的，我们也可以发现很多性能监测工具中只有 Minor GC 和 Full GC。一般情况下，一次 Full GC 将会对年轻代、老年代、元空间以及堆外内存进行垃圾回收。触发 Full GC 的原因有很多：

- 当年轻代晋升到老年代的对象大小，并比目前老年代剩余的空间大小还要大时，会触发 Full GC；
- 当老年代的空间使用率超过某阈值时，会触发 Full GC；
- 当元空间不足时（JDK1.7 永久代不足），也会触发 Full GC；
- 当调用 System.gc() 也会安排一次 Full GC。